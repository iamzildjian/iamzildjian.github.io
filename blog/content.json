[{"title":"漫谈编程语言","date":"2021-01-30T10:54:28.000Z","path":"/talking-about-programming-language/","text":"编程语言，一种特殊的语言。 前言本文来自于 我在公司内部的一次分享。 主要简述了编程语言的阵营，语义的表达形式，不同的思维范式，以及常见规范和执行机制。 正文编程语言三种阵营学术派 You are a poet and a mathematician. Programming is your poetry 语言代表：Haskell Lisp Scala Closure 学术阵营认为编程语言是一种思想的表达。 这些语言往往是从上向下去设计，从一个纯粹的理想角度对语言建模，它们充斥着各种概念: 函数式，类型系统，模式匹配… 它们痛斥操作系统，编译器带来的各种缺陷，所以在设计时 很少去考虑，甚至有的学术派语言 完全找不到相应概念的映射(Lisp)。 虽然它们的结构精妙 概念完美，但从实用角度上 完全不占优势。 主要原因有二： 如果想熟悉学术派编程语言，就必须要先掌握它们背后的设计思想。 就比如想掌握 Haskell，范畴论那套东西你绕不开，因为 Haskell 的基本组成单位就是 Functor。 大部分学术派语言都认为编程的世界应该是“纯”的，它们反感副作用的出现，它们会为副作用的数据提供各种建模，让它们符合“纯”的定义。 有一个典型的例子，使用 Maybe 处理异常： 1234567divBy :: Integral a =&gt; a -&gt; [a] -&gt; Maybe [a]divBy _ [] = Just []divBy _ (0:_) = NothingdivBy numerator (denom:xs) = case divBy numerator xs of Nothing -&gt; Nothing Just results -&gt; Just ((numerator `div` denom) : results) 但是操作系统就是一个副作用的产物。 用垠神的话来说：没有副作用的语言，就像一个没有无线电，没有光的世界，所有的数据都必须通过实在的导线传递，这许多纷繁的电缆，必须被正确的连接和组织，才能达到需要的效果。 不过 它们对现代编程语言的发展做出了很大贡献，现代编程语言中的大多数特性都是来自这个阵营。 就比如 React 提倡的 State 数据不可变模型，reducer 的纯函数特性。 Rust 中的错误处理特性，Kotlin 中的高阶类型等等。 低层派 You are a hacker. You make hardware dance to your tune 语言代表: C C++ Rust Assembly 计算机科学的先驱 Alan Perlis 给低层语言（low-level languages）下的定义是： “A programming language is low level when its programs require attention to the irrelevant.” 如果用一门语言编写的程序需要处理不相关的东西，那这就是一门低层语言。 低层阵营认为编程语言是运行在冯诺依曼机器上的机器码。 这些语言没有学术派语言”那些华丽的外衣”，它们是命令式语言与一点 操作系统/编译器抽象的结合。 虽然从编程角度来说很原始，但它们有最贴近魔法的能力，它们可直接操控内存，手动回收垃圾，从语法角度去进行编译优化，将操作系统/编译器的概念映射得淋漓尽致。 并且它们也是高级语言以及各种基础设施的缔造者。 不过为了有效地编程，必须时刻记住硬件和软件的概念，在往往会让开发者痛苦不堪。 最典型的 烫烫烫错误： img 应用派 You are a maker. You build things for people to use 语言代表: JavaScript Python C# Swift Kotlin PHP 应用阵营认为编程语言是构建应用的一种工具。 这些语言往往是最贴近应用业务的，它们倾向于在特定环境下组合各种功能 模块，而不必太关心底层。 甚至有的应用级开发者，不需要懂操作系统，算法就可以设计出一款精美的应用。 因为在互联网的红利推动下，有很多基础设施已经被实现，所以应用级的开发者 很少在乎底层，这是件可怕的事。 就比如: Java 里的 Int 是 4 个 byte；但是 Go 里的 Int 却和机器的 32bit 还是 64bit 有关；到了 JS 里，压根就没有“整数”的概念，都是“number”。 现代的大部分应用都离不开这些语言，有趣的是，有些语言的最初设计很不规范，幸好它们的社区是最开发繁荣的。 编程语言与语义学编程语言与语言密不可分，都是表达思想的一种工具。 谈起语言 就离不开语义，在编程语言中 语义最明显的表现就是 命名 以及 编程范式(下一章节)了。 正反例子举一些的例子: JavaScript - 命名错误问题 12// 返回两数之和function sub(a，b) { return a + b } Python - API 设计问题 123456# 返回 列表中 出现次数最多的数字# 短短两行代码，做的事情全都隐藏起来了 为了简约 反而给开发者增加了心智负担def most_frequent(lst): return max(set(lst)，key = lst.count)most_frequent([1,2,1,2,3,2,1,4,2]) # 2 Kotlin - 正面例子 1234567891011121314// 根据条件 划分数组data class Person(val name: String，val age: Int)fun main() { val members = listOf( Person(\"Ben\"，85), Person(\"Mel\"，7), Person(\"Lou\"，15), Person(\"Sam\"，22), Person(\"Ash\"，10), ) val (kids，adults) = members.partition { it.age &lt; 18 }} 语义设计可以看出，一个优秀的名称设计是有多么的重要，这里可以细谈一下，名称设计一般分为： 内部变量命名 表示数据 表示状态 函数命名 特定领域命名(不涉及，因为一般都有规范，就比如 React 组件必须大写-骆驼峰) 命名内部数据变量的时候，用名词堆叠 再符合个命名规范就可以了。 比如: 1234const page_count = 5const should_update = trueconst firstName = 'Gustavo'const friends = ['Kate'，'John'] 命名状态变量的时候，一般都是特定动词(has/should/can/is/…)+名词。 比如: 12const hasPagination = postCount &gt; 10const shouldDisplayPagination = postCount &gt; 10 函数命名时，也是有一定规律的。 函数: 动词+名词堆叠+[副词] 而动词 完全可以把它枚举出来，这样大部分场景下，都可以拿来就用。 123addBalance getAccount filterActivityList patchEmails deleteUserByIdremoveItem [generate/gen]TagList fillTableHeader createFolder forEachFileList parseNodeTree updateUserInfoextractUserInfo showTable hideIframe useDebounce toBase64 isSuccess canWrite requestModule loadScript fetchGalleryData setLanguage sendMessage querySelector findElement combineList importResource searchService renderComponent readFile onChange handleInput verifyFormData changeSettings cloneJSON appendSlice insertColumn saveConfig execCommand unloadPage destoryConnection openProgram 单个动词，一般都是 名词.动词，就比如 AST.parse()。 中文编程 文言文编程语言 1234吾有一數。曰三。名之曰「甲」。為是「甲」遍。 吾有一言。曰「「問天地好在。」」。書之。云云。 东北编程语言 易网页 编程范式不同的编程范式 代表了 coding 时 不同的思考维度，下面将简述目前最流行的三种范式。 结构式 everything is command. 结构式编程是最符合冯诺依曼体系的范式，它告诉计算机如何去做事情。 它将逻辑划分成一个个语句，使用最淳朴的方式(循环，分支,顺序)排列起来，然后顺序执行。 FizzBuzz程序的结构式实现： Write a short program that prints each number from 1 to 100 on a new line. For each multiple of 3，print “Fizz” instead of the number. For each multiple of 5，print “Buzz” instead of the number. For numbers which are multiples of both 3 and 5，print “FizzBuzz” instead of the number. 123456789101112131415161718192021package mainimport ( \"fmt\")func main() { for i := 1; i &lt;= 100; i++ { divBy3 := i%3 == 0 divBy5 := i%5 == 0 if divBy3 &amp;&amp; divBy5 { fmt.Println(\"FizzBuzz\") } else if divBy3 { fmt.Println(\"Fizz\") } else if divBy5 { fmt.Println(\"Buzz\") } else { fmt.Println(i) } }} 很淳朴不是嘛。 面向对象 everything is object. 相信很多同学都学过有关面向对象的语言，在我们上课的时候，老师就常提起 面向对象的三大概念: 封装 继承 多态。 其实这个概念一直是错误的。 封装是一个很笼统的概念，函数就是一种封装；并且多态可以理解为向上转型，Python TypeScript 中的 ducking typing 就可以多态；目前看来只有继承是 OOP 的特性。 但 OOP 的主要概念真的是如此吗? 显然不是的。 OOP 主要是提供了一种模块化思想，面向对象范式只是语法层面的思想体现。 它在面向结构式上抽象，根据功能业务 对编程世界进行建模，把代码变成一个个以类为主的组成单元。 有趣的是 大行其道微服务，这两年兴起的微前端，以及底层的微内核 都是这种模块化思想。 在语法上 OOP 由于不支持 函数第一成员的特性，所有的逻辑都只能封装到类的方法中，调用逻辑时只能名词.动词()，这也是面向对象语言 给人造成繁琐的原因。 (其实我还想说，这也是为什么设计模式 这种常见概念能大行其道的原因) 1234567891011121314151617181920class Point{ var x:Int = 0 var y:Int = 0 operator fun plus(p: Point) { x += p.x y += p.y }}fun main(args: Array&lt;String&gt;) { val p = Point() p.x = 8 p.y = 10 val p1 = Point() p1.x = 2 p1.y = 3 val p2 = p + p1 println(\"Point(x = ${p.x}，y = ${p.y})\")} 函数式 everything is lambda. 函数式编程是最符合人思维的范式，它告诉计算机 我们想要什么(声明式编程)。 一提到函数式，纯函数，无状态，数据不可变，副作用，惰性执行等等相关概念都不可避免。 我简述下： 无状态: 不管何时运行，运行多少次，只要给定相同的输入，那输出结果一定是一致的，完全不依赖外部数据。 数据不可变: 顾名思义，数据不可变化，如果想修改数据，那就创建一个新的数据。 副作用: 指的是 函数修改了外部的状态，可以看出 如果保存了数据不可变型，那么函数自然而然就没有副作用了。 纯函数: 如果一个函数保障了 无状态 数据不可变特性，那这个函数就是一个纯函数。 不依赖外部数据，不修改内部数据。 举例: 1234567const person = { name: 'SimonAKing' }// 修改了内部数据const changeName = (person，newName) =&gt; person.name = NewName// 依赖了外部数据const joinName = (text) =&gt; person.name + text 可以看出 函数式本身具备了一种防御性编程的规范。 而函数式编程的主要提供了什么？ 答: 逻辑的组合映射 以及 行为上的分治思想(MapReduce)。 逻辑的组合映射，函数式编程语言提供了很多有关组合映射的工具函数：map、flatMap、foldl、foldr、reduce、filter、compose、partial、curring .. 当然在熟悉它们之前，你需要了解下 各种 Functor: 基本的 Mappable 函子、Pointed 函子、Maybe 函子、Monad 函子等 以及 一些范畴论的知识。 一个简朴的函子: 12345678910class Box { constructor(value) { this.value = value } map (fn) { return new Box(fn(this.value)) }}const value = new Box(1).map(v =&gt; v + 1).map(v =&gt; v * 2) 行为上的分治思想： 给出快排的两种实现，大家可以体会下： 结构式: 123456789101112131415161718192021222324252627282930313233class QuickSort { private static void exch(int pos1,int pos2,List data){ int tmp=data[pos1]; data[pos1]=data[pos2]; data[pos2]=tmp; } private static void partition (int lo,int hi，List a){ if (lo&lt;0||hi&lt;0||lo&gt;=hi-1){ return; } int midValue=a[lo]; int i=lo+1;int j=hi; while (true){ while(i&lt;hi&amp;&amp;a[i]&lt;midValue){ i++; } while(j&gt;lo&amp;&amp;a[j]&gt;midValue){ j--; } if (i&gt;=j) break; exch(i,j,a); } exch(i,lo,a); partition(lo,i-1,a); partition(i+1,hi,a); } public static List sort(List a){ int low=0; int hight=a.size()-1; partition(low，hight，a); return a; }} 函数化: 12345678const quickSort = a =&gt; { if (!a.length) { return [] } return [ ...quickSort(a.filter(e =&gt; e &lt; a[0])), ...a.filter(e =&gt; e === a[0]), ...quickSort(a.filter(e =&gt; e &gt; a[0]))]} 就像章节开始所说的那样：结构式编程是最符合冯诺依曼体系的范式，它告诉计算机如何去做事情；函数式编程是最符合人思维的范式，它告诉计算机 我们想要什么。 具体选哪种范式，还是要根据场景来结合。 如果你的场景适合业务领域建模，很容易找到不同的模型以及模型间关系的话，那么 OOP 显然是最优的。 如果你的场景 主要是对数据的加工，就比如对一数组先排序再筛选 然后映射得到结果的话，FP 就很自然。 编程规范SOLID 原则 S：单一职责原则 一个模块只能做一件事。 O：开闭原则 增加新功能时，模块应该是支持扩展的，而不是提倡修改，多态的最佳实践。 L：里氏替换原则 子类必须可以替换它的超类，向下转型的最佳实践。 I：接口隔离原则 接口设计时应该衡量细粒化，而不是设计一个笼统的接口。 D：依赖反转原则 高级模块不应该依赖于低级模块。两者都应该依赖于抽象。 抽象不应该依赖于细节。细节应该依赖于抽象。 注入实现了相同接口的逻辑。 防御性编程防御性编程往往是从编程角度去提升工程质量，减少 Bug。 刚刚提到函数式语言的思想就很实用。 拒绝写副作用代码 不要与外部状态相互关联，尽量将所需数据全部输入。 比如典型的副作用 JS-API: sort，reverse，splice，最好能不用就不用。 不要共享引用 如果说 null 的设计是一亿美金的失误，那么 堆上对象共享引用 的设计可以算上得百亿美金的失误。 如果遇到共享引用的变量情况，请不要碰它。 尽量写纯函数 尽量将数据流统一化 统一语言规范，使用相同的 lint 工具，相同的语法规范 容错处理，正视程序出现的每一个异常 API 接口设计时 对输入尽可能的保持严谨，对输出保持开发 不要相信网络请求，每一次网络请求都有可能失败 抽象化原则 DRY - Don’t Repeat Yourself 尽量在项目中减少重复的代码。 KISS - Keep It Simple &amp; Stupid 代码应该保持简单易懂。 YAGNI - You Ain’t Gonna Need It 不要进行过度化设计，会延缓开发效率。 编程语言如何执行编译型语言编译型语言是将源代码经过词法分析，语法分析，生成 AST，然后在转成中间代码的形式，经过优化器优化后 再生成目标机器的机器码。 优化涉及到的一些点： 去掉无意义的数据 (无法运行到的代码，没有利用的数据) 内联函数，尾递归优化 解语法糖 … 代表语言: C，C++，Go 解释型语言解释型语言，不能直接生成机器码，而是先翻译成中间代码，再有解释器对中间代码进行解释运行。 代表语言: Python，Lua 解释编译型语言由于即时编译技术(JIT)的存在，可以将热点代码直接编译成字节码 来提高程序执行的效率，越来越多的语言开始使用，就比如最近推出的 Ruby3。 JavaScript 也是一个很好的例子。 V8 运行 JS 的过程 源代码(source code) 通过解析器(parser) 解析后 生成抽象语法树(AST)。 抽象语法树 通过 解释器(interpreter-Ignition) 生成了字节码(bytecode)，此字节码作为基准执行模型，字节码等同于 25%-50% 机器码大小。 并且 此时抽象语法树被彻底清除掉了，释放其内存空间。 生成后的字节码 直接被 解释器执行 (解释执行)。 在代码不断的运行过程中，解释器收集到了很多可以优化代码的信息，比如变量的类型，哪些函数执行的频率较高。 V8 引擎的编译器(compiler-TruboFan) 会根据这些信息和字节码 来编译出经过优化的机器代码。 一些常见的优化规则： 函数只是声明未被调用，那么该函数不会生成到 AST 函数如果只被调用一次，字节码则直接被解释执行了 如果函数被调用多次，可能会被标记为热点函数，会被编译成机器代码 随着不断执行，会有越来越多的代码被标记为热点代码，然后被编译成机器码。 所以 JS 运行的过程 正是一个从解释执行到编译执行的过程。 注意在某些情况下，优化后的机器代码可能会被逆向还原成字节码。 12345678910const sum = (a,b) =&gt; a + bsum(1,2)// 假设调用了多次 sum 函数// sum 函数在编译器优化后的机器码 将是 int 类型的参数sum('1'，'2')// 此时 参数的类型发生变化，V8 将会发生 deoptimization 的过程// 机器码不知道如何处理 string 类型参数，也就是回退到字节码，由解释器解释执行// 所以 coding 时，热点函数不要随便改变类型 未来编程语言设想 完全不涉及编译器的概念 语义设计优秀，写代码就像写诗一样 无 GC 强类型系统，支持强大类型建模 各领域都有对应的丰富生态 优雅错误处理，强行让开发者正视逻辑错误，可是忽视潜在错误 强大的工具链，具有比较统一的编程风格，lint 工具，包管理器 可以完全利用多核的能力 可以面向 GPU 编程 支持多种编程范式 跨平台，无需虚拟机，可编译成机器码 在语法层面提供并发原语 推荐阅读 3 tribes of programming 编程的宗派 思考的价值-PL 思考的价值-Coding 前端 DSL 实践指南（上）—— 内部 DSL Learn Advanced TypeScript Types Java 即时编译器原理解析及实践 函数式编程进阶：杰克船长的黑珍珠号 编程的智慧 结束语转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。 .post-toc{overflow-y: auto; overflow-x: hidden; height: 35em;}","categories":[{"name":"随笔","slug":"随笔","permalink":"https://tomotoes.com/blog/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://tomotoes.com/blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"总结","slug":"总结","permalink":"https://tomotoes.com/blog/tags/%E6%80%BB%E7%BB%93/"},{"name":"编程语言","slug":"编程语言","permalink":"https://tomotoes.com/blog/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"前端架构发展史","date":"2021-01-22T14:21:04.000Z","path":"/history-of-front-end-architecture/","text":"前端改革 30 年，从一片荒芜到微前端兴起。 前言本文主要简述前端系统级架构的演讲历史，不涉及应用级架构: MVC，MVMM… 正文前置术语 应用：指的是一个整体的应用，可由多个模块组成。 模块：指的是整体应用下 被划分的子应用。 无架构在 1990 年，Tim Berners-Lee 在他的 NeXT 电脑上部署了第一套“主机-网站-浏览器”构成的 Web 系统，这标志着前端的开始。 在最初，前端是一片荒芜的，经过浏览器大战，W3C 标准化的过程 前端才慢慢成长了起来。 在此时期，诞生了 CSS、JavaScript、DHTML 等重要技术。前端也从最开始的纯静态页面，逐步存在于 PHP、ASP、JSP 这些模板技术中。 由于前端涉及到的功能简单，只需操作 DOM，并不需要代码管理与模块支持。 所以 最初的前端只是 MVC 架构中的 View，如下面的模板，没有架构可言。 1234567891011&lt;html&gt; &lt;head&gt;&lt;title&gt;Car {{ $car-&gt;id }}&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Car {{ $car-&gt;id }}&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Make: {{ $car-&gt;make }}&lt;/li&gt; &lt;li&gt;Model: {{ $car-&gt;model }}&lt;/li&gt; &lt;li&gt;Produced on: {{ $car-&gt;produced_on }}&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 前后端分离架构在 1999 年，IE 浏览器支持了 XMLHttpRequest 接口，允许 JavaScript 异步发出 HTTP 请求，这为以后的前端发展 埋下了重要伏笔。 2005 年，在 Google 广泛应用 Ajax 通信 获得一系列产品成功后，这种不需要刷新页面就可以与服务器通信的技术 开始被开发者所重视。 但 Ajax 带来的不仅是一种可异步通信的技术，而是开发模式上的解耦。 前端不再是后端的模板，前端也可以实时地获取数据，动态地渲染内容。 在此时期，前端逐步从纯内容展示的静态网页 向 具备数据交互的动态网页转变，前端开发变得复杂起来。 与此同时，互联网带来的商业价值 推动了其他技术的产生，这其中就包括了 大名鼎鼎的 V8 。 在 V8 开源的第二年，Nodejs 出现了，让 JS 可以 run everywhere。 也正是因为它把前端快速带进了刀耕火种时代，其中最受益的就是工程化的兴起。 构建工具：gulp webpack 包管理：npm yarn 排名第一的包生态 除此之外，标准化组织 W3C 也在 08 年发布 HTML5 正式草案。 随着资本的重视，工程化的兴起，开源社区的努力，开发模式的创新，整个前端开发 开始呈现野蛮增长现象。 从 2010 年 10 月出现的 Backbone 开始，Knockout、Anjular、Ember、Meteor、Vue 相继出现，前端开发颇有一副 不管 MVC 、MVVM 还是 全栈开发，我全都要的气势。 在此期间，有一股潮流慢慢被大家所认可，就是单页面应用。 但单页面应用代表的不只是工程技术化的产物，而重要的是一种网页 应用化的思想。 而随着单页面应用的流行，移动端的兴起，前后端分离的架构也成为了行业的标准实践。 由此，前端不再是后端 MVC 中的 V，而是单独的一层。 前端开始进入前后端分离时代。 微前端架构微前端的概念由 ThoughtWorks 于 2016 年的一期技术雷达提出, 摘自技术雷达: 我们已经从引入微服务架构中获得了明显的好处，微服务架构可以让团队裁剪出独立部署的交付物以及可维护的服务。不幸的是，我们还看到许多团队在后端服务之上创建了前端单体——一个单一，庞大和杂乱无绪的浏览器应用。我们首选的（经过验证的）方法是将基于浏览器的代码拆分成微前端。在这种方法中，Web 应用程序被分解为多个特性，每个特性都由不同的前后端团队拥有。这确保每个特性都独立于其他特性开发，测试和部署。这样可以使用多种技术来重新组合特性——有时候是页面，有时候是组件——最终整合成一个内聚的用户体验。 “微”是一个很神奇的概念，底层的微内核设计，大行其道的微服务概念，以及本章的微前端主题。 微 实质上代表的概念是模块化，而模块化具有的思想是: 单一职责、关注分离，分而治之，这些思想 在软件工程中体可谓是金玉良言。 在我看来 微前端的出现 是一种趋势，是 WEB2.0 时代应用复杂性的一种体现，也标志着前端从刀耕火种的时代跨入了工业化时代。 在一些小型应用中，往往几个 单页面就足以支撑起整个应用。 而在一些中大型的应用中，业务的复杂性、工程的庞大性 都难以控制，如果继续使用传统的开发模式，不仅应用的状态难以管理，打包出来的应用难以优化，就连协作开发都存在很大的耦合性。 微前端 使用去中心化的思想可以有效分解大型应用的复杂度，将大型应用划分成一个个独立的模块，根据功能、业务场景来进行自由编排，这些模块通过统一的入口注册组合，通过约定的方式来进行通信，各个模块可以做到并行开发，独立部署，而且技术栈也随之解耦。 Application 但是微前端并不是提升研发效率的银弹，需要根据具体场景来衡量是否使用，而架构就是权衡的艺术，微前端为我们提供了一种系统级的维度。 使用场景适合场景 聚合型的应用 这种应用主要存在 业务场景多样且业务之间依赖性很低的场景。 就比如 Top 运营系统，每一个模块都可以单独抽成一个应用进行开发 且 满足单一职责原则，替换掉某一模块时也不会影响全局应用。 逻辑重复型的应用 这种应用的特征是，子模块之间存在很多共同的业务逻辑，重复建设严重。 就比如 电商系统，在 PC 端，H5 终端 都会有商品推荐，购买商品这些基本的功能，属于业务逻辑基本相同，UI 相差较大。 微前端可以将子模块之间相同的业务逻辑 提取到主应用，然后各个子模块通过约定的方式进行通信，这样子模块的维护性会得到提升。 需保留老模块的应用 在现代的前端开发时，由于技术栈日新月异，如何处理遗留模块 是一个无论绕过的问题。 如果旧模块可以继续使用，并且重写需要花很多时间力气的话，那么使用微前端 整合进现有应用是一个很好的方案。 需数据隔离的应用 数据隔离指的是 状态隔离，样式隔离。 如果一个应用的单个页面存在多种模块时，数据冲突 不能忽视，比如模块中的全局变量，事件，通用样式 很可能造成问题。 这种问题通常需要”沙箱化”来解决，而微前端提供了很好的实践。 “沙箱化”还能提供应用的容错性，当一个子模块出现错误时，不会影响到全局应用，真正做到弹性应用。 技术栈灵活的应用 使用微前端在系统级层面进行模块地抽象组合，磨平了不同技术栈带来的差异,做到模块之间技术栈的隔离。 在同一应用下 每个团队可以根据自身需求，选择最合适自己的技术栈。 需要敏捷化开发的应用 因为微服务提供了 模块级的组件化架构，完全可以做到多个模块之间并行开发，独立部署，无论模块的需求如何增长，都不会影响到全局应用。 并且天然的增量构建，有利于持续部署。在团队协作开发层面也是一种很好的实践。 无法可持续迭代的应用 这种应用一般都是巨石型应用，存在的问题很明显: 随着业务需求的迭代，代码量级越来越大，开发效率越来越低，新业务的接入成本随之变高。 这种场景只能从技术维度来进行切入,需将巨石应用划分模块来处理臃肿。 不适合场景 应用之间存在很强的业务依赖 或者 拆分的粒度很难掌握，如果强行使用微前端规范，很可能起到相反的作用。 小型应用，没必要过度设计。 对性能有要求的应用，微前端因为多加了一层抽象，如果不是从工程化进行模块组合的话，极有可能为页面增加很多无意义的网络请求,内存消耗，影响最终的用户体验。 基础设施较弱的应用。 结束语下篇文章将讲述微前端的实践原理，敬请关注。 转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。","categories":[{"name":"前端","slug":"前端","permalink":"https://tomotoes.com/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://tomotoes.com/blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"前端","slug":"前端","permalink":"https://tomotoes.com/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"架构","slug":"架构","permalink":"https://tomotoes.com/blog/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"思考的价值","date":"2021-01-16T06:43:29.000Z","path":"/thinking/","text":"论如何科学地提升自己。 前言在互联网时代，知识从未像如此一般廉价，但是再好的知识若是没有产生价值，那也只不过是一种信息噪音罢了。 在我看来，只要能让人产生思考的文字、图片、媒体资源 就是有价值的，有分享价值的。 所以，我创建了一个思考的价值微信群，立志于分享高质量信息 以及 与志同道合的同学 交流各种观点、产生思考，从而达到沉淀自己、提升自己。 正文输出由于使用微信群的方式，很多时候 有价值的信息都会被时间掩埋，并且当卸载微信或者换手机时，聊天记录也会丢失。 基于这些痛点，我创建了个站点：https://thinking.tomotoes.com/ 站点里的内容 皆来自于 思考的价值 微信群，它记录了 自从建群以来 每天有价值的信息。 站点导航: 具体的分享领域 讨论过的事物 某一周分享的汇总 如果你对输出的内容很感兴趣，随时欢迎加群一起交流。 目前思考的价值里面的群友不多，但都是想提升自己 有明确方向的同学。 最近我变成了打工人，所以 群里信息分享的密度不会如之前那么大。 须知在加群之前请先仔细阅读以下条目： 如果你觉得不舒服或者因为其他原因，可以随时退群。 在我看来 这是双向选择的事情，我完全理解。 群里的信息 大部分都是以 我的视角来分享的，存在的问题很明显： 信息不会照顾到每一个同学。所以 当你碰到好玩或者有价值的信息时，可以随时分享。 信息是不应该有限制的，而成长也是不应该给自己树立边界的。 关于闲聊 只要不涉及到国家时政以及违法法律、性低俗的主题，都可以随时在群里发起一个 Thread 来讨论。 此群可以当作一个信息流来看待，你可以选择不分享，做一个潜水运动员。 如果你有不同的观点，或者分享一些感触很深的信息时 请不要有心理负担，不要在乎没人回复。 思考的价值站点的 Talk 页面，会记录群里一些有价值的讨论。但请放心 所有人都是以字母代称出现，不会涉及任何人的隐私、微信昵称。 如果你对分享的内容完全不感兴趣 或者 不想提升自己，只是想找个地方闲聊一些低级趣味的主题，此群不适合你也不欢迎你。 入口如果你也想加群学习交流，欢迎添加我的微信：simonaking 或者扫描下方的二维码。 并且如果认识 有相同意向的同学, 可以随时拉她/他进群 :) wechat 结束语转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://tomotoes.com/blog/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://tomotoes.com/blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"成长","slug":"成长","permalink":"https://tomotoes.com/blog/tags/%E6%88%90%E9%95%BF/"}]},{"title":"React 的 7 种代码异味[译]","date":"2020-11-15T02:57:51.000Z","path":"/7-code-smells-in-react-components/","text":"教你如何更好地写 React。 前言原文链接：7 code smells in your React components 作者信息：Anton Gunnarsson 翻译许可： Agree 正文自从使用 React 后，我见过越来越多可值得优化的点，比如： 大量的 props props 的不兼容性 props 复制为 state 返回 JSX 的函数 state 的多个状态 useState 过多 复杂的 useEffect 在本文中，我想分享几个技巧，这些技巧将改善你的 React 代码。 大量的 props如果需要把大量的 props 传递到一个组件中，那么很有可能 该组件可再进一步拆分。 问题来了，“大量” 具体是多少呢？答案是 看情况。 假设你正在开发 一个包含 20 个或更多 props 的组件时，你想再添加一些 props 完善其他功能，这时有两点可以参考 是否应拆分组件： 该组件是否做了多件事？ 像函数一样，一个组件应该只做好一件事，所以考虑下 将组件拆分成多个小组件是否会更好。 例如，该组件存在 props 的不兼容性 或 返回 JSX 的函数。 该组件是否可被合成？ 开发中，组合是一种很好的模式但经常被忽视。 如果你的组件中存在将不相干逻辑塞到一起的情况，是时候考虑使用组合了。 假设我们有一个表单组件来处理某组织的用户信息: 123456789&lt;ApplicationForm user={userData} organization={organizationData} categories={categoriesData} locations={locationsData} onSubmit={handleSubmit} onCancel={handleCancel} .../&gt; 通过该组件的 props ，我们可看到它们都与组件提供的功能密切相关。 该组件看起来并无大碍，但如果将其中的一些 props 分担到子组件，那么数据流就会更清晰。 123456&lt;ApplicationForm onSubmit={handleSubmit} onCancel={handleCancel}&gt; &lt;ApplicationUserForm user={userData} /&gt; &lt;ApplicationOrganizationForm organization={organizationData} /&gt; &lt;ApplicationCategoryForm categories={categoriesData} /&gt; &lt;ApplicationLocationsForm locations={locationsData} /&gt;&lt;/ApplicationForm&gt; 现在，我们已经看到该表单组件只处理提交和取消动作，其他范围内的事情，都交给了对应的子组件。 是否传递了很多有关配置的 props 在某些情况下，将多个有关配置的 props 组合成一个 options 是个不错的实践。 假设我们有一个可显示某种表格的组件： 12345678910&lt;Grid data={gridData} pagination={false} autoSize={true} enableSort={true} sortOrder=\"desc\" disableSelection={true} infiniteScroll={true} .../&gt; 我们可以很清楚地看出，该组件除了 data 外其余的 props 都是与配置有关的。 如果将多个配置 props 合成为一个 options ，就可更好地控制组件的选项，规范性也得到提升。 1234567891011121314const options = { pagination: false, autoSize: true, enableSort: true, sortOrder: 'desc', disableSelection: true, infiniteScroll: true, ...}&lt;Grid data={gridData} options={options}/&gt; props 的不兼容性避免组件之间传递不兼容的 props。 假设你的组件库中有一个 &lt;Input /&gt; 组件，而该组件开始时仅用于处理文本，但过了一段时间后，你将它用于电话号码处理。 你的实现可能如下： 12345function Input({ value, isPhoneNumberInput, autoCapitalize }) { if (autoCapitalize) capitalize(value) return &lt;input value={value} type={isPhoneNumberInput ? 'tel' : 'text'} /&gt;} 问题在于，isPhoneNumberInput 与 autoCapitalize 之间并不存在关联，将一个手机号首字母大写是没有任何意义的。 在这种情况下，我们可以将其分割成多个小组件，来明确具体的职责，如果有共享逻辑，可以将其放到 hooks 中。 123456789101112function TextInput({ value, autoCapitalize }) { if (autoCapitalize) capitalize(value) useSharedInputLogic() return &lt;input value={value} type=\"text\" /&gt;}function PhoneNumberInput({ value }) { useSharedInputLogic() return &lt;input value={value} type=\"tel\" /&gt;} 虽然上面例子有点勉强，可当发现组件的props存在不兼容性时，是时候考虑拆分组件了。 props 复制为 state如何更好地将 props 作为 state 的初始值。 有如下组件： 12345function Button({ text }) { const [buttonText] = useState(text) return &lt;button&gt;{buttonText}&lt;/button&gt;} 该组件将 text 作为 useState 的初始值，可能会导致意想不到的行为。 实际上该组件已经关掉了 props 的更新通知，如果 text 在上层被更新，它将仍呈现 接受到 text 的第一次值，这更容易使组件出错。 一个更实际场景是，我们想基于 props 通过大量计算来得到新的 state。 在下面的例子中，slowlyFormatText 函数用于格式化 text，注意 需要很长时间才能完成。 12345function Button({ text }) { const [formattedText] = useState(() =&gt; slowlyFormatText(text)) return &lt;button&gt;{formattedText}&lt;/button&gt;} 解决此问题 最好的方案是 使用 useMemo 代替 useState。 12345function Button({ text }) { const formattedText = useMemo(() =&gt; slowlyFormatText(text), [text]) return &lt;button&gt;{formattedText}&lt;/button&gt;} 现在 slowFormatFormat 仅在 text 更改时运行，并且没有阻断 上层组件更新。 进一步阅读：Writing resilient components by Dan Abramov。 返回 JSX 的函数不要从组件内部的函数中返回 JSX。 这种模式虽然很少出现，但我还是时不时碰到。 仅举一个例子来说明: 123456789101112131415161718192021222324252627282930313233function Component() { const topSection = () =&gt; { return ( &lt;header&gt; &lt;h1&gt;Component header&lt;/h1&gt; &lt;/header&gt; ) } const middleSection = () =&gt; { return ( &lt;main&gt; &lt;p&gt;Some text&lt;/p&gt; &lt;/main&gt; ) } const bottomSection = () =&gt; { return ( &lt;footer&gt; &lt;p&gt;Some footer text&lt;/p&gt; &lt;/footer&gt; ) } return ( &lt;div&gt; {topSection()} {middleSection()} {bottomSection()} &lt;/div&gt; )} 该例子虽然看起来没什么问题，但其实这会破坏代码的整体性，使维护变得困难。 要么把函数返回的 JSX 直接内联到组件内，要么将其拆分成一个组件。 有一点需要注意，如果你创建了一个新组件，不必将其移动到新文件中的。 如果多个组件紧密耦合，将它们保存在同一个文件中是有意义的。 state 的多个状态避免使用多个布尔值来表示组件状态。 当编写一个组件并多次迭代后，很容易出现这样一种情况，即内部有多个布尔值来表示 该组件处于哪种状态。 比如下面的例子： 123456789101112131415161718192021222324function Component() { const [isLoading, setIsLoading] = useState(false) const [isFinished, setIsFinished] = useState(false) const [hasError, setHasError] = useState(false) const fetchSomething = () =&gt; { setIsLoading(true) fetch(url) .then(() =&gt; { setIsLoading(false) setIsFinished(true) }) .catch(() =&gt; { setHasError(true) }) } if (isLoading) return &lt;Loader /&gt; if (hasError) return &lt;Error /&gt; if (isFinished) return &lt;Success /&gt; return &lt;button onClick={fetchSomething} /&gt;} 当按钮被点击时，我们将 isLoading 设置为 true，并通过 fetch 执行网络请求。 如果请求成功，我们将 isLoading 设置为 false，isFinished 设置为 true，如果有错误，将 hasError 设置为 true。 虽然这在技术上是可行的，但很难推断出组件处于什么状态，而且不容易维护。 并且有可能最终处于“不可能的状态”，比如我们不小心同时将 isLoading 和 isFinished 设置为 true。 解决此问题一劳永逸的方案是 使用枚举来管理状态。 在其他语言中，枚举是一种定义变量的方式，该变量只允许设置为预定义的常量值集合，虽然在JavaScript 中不存在枚举，但我们可以使用字符串作为枚举： 123456789101112131415161718192021function Component() { const [state, setState] = useState('idle') const fetchSomething = () =&gt; { setState('loading') fetch(url) .then(() =&gt; { setState('finished') }) .catch(() =&gt; { setState('error') }) } if (state === 'loading') return &lt;Loader /&gt; if (state === 'error') return &lt;Error /&gt; if (state === 'finished') return &lt;Success /&gt; return &lt;button onClick={fetchSomething} /&gt;} 通过这种方式，完全杜绝了出现 不可能状态的情况，并更利用扩展。 如果你使用 TypeScript 开发的话，则可以从定义时就实现枚举： 1const [state, setState] = useState&lt;'idle' | 'loading' | 'error' | 'finished'&gt;('idle') useState 过多避免在同一个组件中使用太多的 useState。 一个包含许多 useState 的组件可能会做多件事情，可以考虑是否要拆分它。 当然也存在一些复杂的场景，我们需要在组件中管理一些复杂的状态。 下面是自动输入组件的例子： 1234567891011121314151617181920212223function AutocompleteInput() { const [isOpen, setIsOpen] = useState(false) const [inputValue, setInputValue] = useState('') const [items, setItems] = useState([]) const [selectedItem, setSelectedItem] = useState(null) const [activeIndex, setActiveIndex] = useState(-1) const reset = () =&gt; { setIsOpen(false) setInputValue('') setItems([]) setSelectedItem(null) setActiveIndex(-1) } const selectItem = (item) =&gt; { setIsOpen(false) setInputValue(item.name) setSelectedItem(item) } ...} 我们有一个 reset 函数，可以重置所有状态，还有一个 selectItem 函数，可更新一些状态。 这些函数都离不开 useState 定义的状态。如果功能继续迭代，那么函数就会越来越多，状态也会随之增加，数据流就会变得模糊不清。 在这种情况下，使用 useReducer 来代替 过多的 useState 是一个不错的选择。 1234567891011121314151617181920212223242526272829303132333435363738const initialState = { isOpen: false, inputValue: \"\", items: [], selectedItem: null, activeIndex: -1}function reducer(state, action) { switch (action.type) { case \"reset\": return { ...initialState } case \"selectItem\": return { ...state, isOpen: false, inputValue: action.payload.name, selectedItem: action.payload } default: throw Error() }}function AutocompleteInput() { const [state, dispatch] = useReducer(reducer, initialState) const reset = () =&gt; { dispatch({ type: 'reset' }) } const selectItem = (item) =&gt; { dispatch({ type: 'selectItem', payload: item }) } ...} 通过使用 reducer，我们封装了管理状态的逻辑，并将复杂的逻辑移出了组件，这使得组件更容易维护。 进一步阅读：state reducer pattern by Kent C. Dodds。 复杂的 useEffect避免在 useEffect 中做太多事情，它们使代码易于出错，并且难以推理。 下面的例子中 犯了一个很大的错误： 1234567891011function Post({ id, unlisted }) { ... useEffect(() =&gt; { fetch(`/posts/${id}`).then(/* do something */) setVisibility(unlisted) }, [id, unlisted]) ...} 当 unlisted 改变时，即使 id 没有变，也会调用 fetch。 正确的写法应该是 将多个依赖分离： 12345678910111213function Post({ id, unlisted }) { ... useEffect(() =&gt; { // when id changes fetch the post fetch(`/posts/${id}`).then(/* ... */) }, [id]) useEffect(() =&gt; { // when unlisted changes update visibility setVisibility(unlisted) }, [unlisted]) ...} 结束语以上就是我分享的全部。请记住，这些绝不是规则，而是表明某些东西可能是“错误的”。 如果你也发现了其他的问题模式，欢迎发表评论，或者在 Twitter 上联系我。 转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。","categories":[{"name":"前端","slug":"前端","permalink":"https://tomotoes.com/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"译文","slug":"译文","permalink":"https://tomotoes.com/blog/tags/%E8%AF%91%E6%96%87/"},{"name":"前端","slug":"前端","permalink":"https://tomotoes.com/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"https://tomotoes.com/blog/tags/React/"}]},{"title":"拯救者 Y9KK 换机指南","date":"2020-05-27T05:18:58.000Z","path":"/Y9KK/","text":"AMD！YES！R7K！NO！Y9KK! YES! 前言我的第一个笔记本也是我现在 正在使用的笔记本，是 16 年花了五千大洋购入的华硕的暗影战神。 当时很年轻没有做功课，只是想买台笔电打打DNF，写写代码这样。 在逛了秦皇岛的几条街后，感觉笔记本都差不多，也不知道什么配置，就草草下单了。 现在看来，这台笔电在当时就是个坑： 4G 内存，DDR3 1T 机械硬盘 intel 4 代 双核标压 N 卡 980，2G 显存 5200 毫安的电池 2.7kg 的重量 买完之后，打两局LOL就烫手，打开个Chrome内存基本就没了… 幸好后来在大学这两年，我相继买入了内存条+固态，才勉强维持得了生活。 前不久因为找到了实习工作，所以多年一直蠢蠢欲动 换电脑的想法 也随之强烈起来。 我是非常想换Macbook Pro的，可惜那两万多的价钱对学生党太不友好了。 所以想了想还是先买台Windows笔电过渡，MBP等以后再说。 正文笔电选择经过数个小时的挑选，我最后锁定了如下的五款笔电： 联想 Y9000X 一款走极客风格的笔电，我当时看到它的时候就差点下单了。 后续想了想，就算自己没有游戏需求，GPU也同样很重要的。 在计算机方面，除了深度学习方面的框架，我也曾看到过不少使用GPU作为加速计算的项目。 另外 9K 的价格换了一块 4K 屏，总感觉怪怪的，笔记本真的需要 4K 屏吗？ 联想小新 Pro（15.6） 性价比很强！但是 CPU 是 intel 低压，主频只有 1.1 赫兹。 并且只有 13.1 寸屏才提供 16：10、2k 屏的特性，有点遗憾。 联想 R7000(已购) 暗影骑士氢 性价比也很高，但是比起 R7000 来说，CPU 不但打不过，价钱还高了近 1000。 机械革命 17.3 寸 144hz 高色域大屏 + 自带机械键盘 确实很吸引人，但感觉花大价钱买个“纯”游戏本，总觉得有点浪费。 由经过了数轮筛选 + 参数对比，结合着自己当下的需求，我最终选择了联想 R7000。 理由很简单：在 5.5k 这个价位，R7000 无疑是性价比最高的，并且配置上 AMD 4800H （8 核 12 线程）的 CPU，可以说吊打一切，关于这点 我查了很多外网上面的权威网站，可以说目前移动端 AMD 4800H 没有敌手。 除了强大的 CPU 心脏，它的内存也是一大亮点：16G-3200MHZ，市面上都很少见速度这么高的内存，而众所周知 计算机的瓶颈就在于 IO，这让我很喜欢。 如果要说不足之处，最显而易见的就是显卡了。 R7000 搭载了 1650 显卡，60hz 高色域屏，这个显卡有点拉，但是我平时就打打守望，1650 显卡也足够我用了。 另外，因为是游戏本的缘故，R7000 净重达到了 2kg 以上，呃，练武之人标配。 电池方面 也中规中矩，60Wh 不过可以自己手动换电池。 当然了，R7000 在本身提供了 512SSD 的同时，也留出了添加固态/机械硬盘的地方。 其余最大的坑就是抽奖机制了，以下硬件均为混搭： 内存*2 三星 海力士 西部数码 屏幕 京东方 龙腾 因为硬件混搭，网上有很多“一等奖”、“二等奖”的说法，但如果验机没有大问题的话，其实不必在意硬件的差别。 如何验机硬件篇开机前 查看是否出现 包装损坏严重或机器已经被拆封。 检查外观是否出现划痕、指纹、掉漆。 液晶屏是否有划伤、磨损、指纹。 检查摄像头的物理拨片。 检查键盘是否出现问题。 检查触摸板按压是否出现问题。 D 面底脚是否有磨损。 配件是否齐全。 轻轻摇晃笔记本电脑，听是否有异响。 查看螺丝是否有拆卸的痕迹。 开机后 检查（联保凭证、说明书）的序列号是否与机身序列号、（BIOS 中的序列号 (AIDA64 -&gt; 计算机 -&gt; 系统概述 -&gt; DMI -&gt; 主板序列号)、Windows 系统 -&gt; 关于 -&gt; 序列号。相同。 查看在不通电源的情况，是否能开机，如果开机成功，那就意味着买到了二手货。 在黑暗情况下，反复开机，检查屏幕是否漏光，如不严重就算正常。 使用软件或纯色图检查屏幕坏点。 一般来说，有 1-3 个坏点算正常，太多了就不正常了。 摄像头是否正常。 是否可以正常播放声音 仔细听是否有杂音、破音等异响。。 软件篇先不联网，不激活系统，不激活 Office，用默认管理员开机，不然就无法享受七天无理由退货了。 进入 BIOS 查看信息是否一致。 查看接口是否正常。 系统硬件管理器各部件驱动是否正常，是否有未识别硬件。 卡硬工具箱 的各种工具。 图吧工具箱 的各种工具。 其实4,5点是重点，它们几乎整合了市面上所有知名的测评软件，非常推荐。 系统设置重装系统如果 windows 2004 专业版在买完之后已经推送，那么我很乐意做第一个吃螃蟹的人。 否则 就安装 windows 1909 专业版。 后续：现已推送 2004。 硬盘分区 C 盘 400G (系统/软件) D 盘 112G (文档/冷数据) 我现在这台使用了近 4 年的笔电，实际花费存储空间也就不到256G。 所以说，512G 够我用一段时间了。 细节设置 色彩校正 输入法改为双拼 先过一遍 windows 设置 使用 Dism++ 更深入地修改系统功能 管理员权限 开机免输入密码 电源管理合上盖子操作 高性能模式设置 桌面，开始页面图标设置 关闭 Windows Defender Bios 更新 驱动更新 暂时就想到这么多，先跳过。 软件安装我估计这是本篇文章中最花费时间的章节，因为我本身就是一个收集癖，还喜欢折腾各种效率的软件，这几年积累了不少，所以说，以下都是我的藏家宝。 Chrome 书签，设置都会同步，而插件方面，大部分单机插件都会自动同步下载，其中一些需要配置文件的插件需要手动同步，比如: stylus,crxMouse,vimium 等。 plugin 呃，这就是我 chrome 上的所有插件，还挺多吧。 网易云音乐，平时就听个响。 阿里邮箱 Telegram Typora，所见即所得的 markdown 编辑器 Xmind8 脑图软件，有时会用到 微软 TODO，一款强大的跨平台 TODO 软件，用了很多年了 Postman 接口调试软件 Everything 搜索软件，强大得不用解释 Wallpaper Engine 第一人称射击游戏，懂得都懂… SpaceSniffer 可视化查看硬盘空间分布的软件 Scrcpy/ScrcpyGui 自己写的控制手机的软件 火绒 - 杀毒软件 卡硬工具箱 图吧工具箱 EarTrumpet 强化版声音管理软件，可单独设置某软件的声音 OBS Studio 知名推流软件, 我用来录屏 WGesture 超级厉害的手势软件，可谓是一大效率神器 Ditto 历史剪切板 Snipaste 截图工具 Seer 快速查看文档神器，就好比 Mac 上对文件的空格键 TranslucentTB 任务栏透明软件 Bandzip 解压缩工具 FileMenu Tools 可直接右键复制文件路径 QTTabBar 一款强大的标签化资源管理器, 效率神器 MacType windows 下字体渲染优化软件 PotPlayer windows 下播放视频软件 Git 版本控制软件 Terminus，一款 Shell 终端的可视化软件，又好看又能打 WSL Notepads APP 可替代原生的 windows 记事本 *pn 小飞机 Stream 暴雪游戏平台 WeGame FDM 下载文件神器 VSCode 轻量级编辑器，可借助Settings Sync插件，来同步配置。 xshell / xftp Gradle - better maven 字体 - Roboto/FairCode/source-code-pro/JetBrainsMono 到货后续京东方是 6.1 日正式开售，所以等到下周才能收到货了。 呐，先留个坑~ 6.2 日上午到货了，我抽到的配置是双三星 + 龙腾屏，然而我是真没想到屏幕会翻车。 昨天测试屏幕下来，有不少明显的问题： 拖影严重，效果不及我的老笔电。 这是 R7000 与我老笔电的对比图： asus1 legion 漏光严重，四面皆漏光。 legion-light 屏幕泛黄，不通透，调了一晚上色温，最后头都大了，效果也一般。 屏幕仔细看有竖条阴影，横条阴影。 屏幕坏点也不少。 说实话，我是真不想退货瞎折腾，可是屏幕是最重要的外设之一，内存固态可以次一点，反正性能早就过剩了，可屏幕真忍不了。 并且，网上反复换货依旧是龙腾屏的例子也有很多，所以我直接选择退了。 现在系统已激活，本以为京东方不会同意我退货的申请，结果却同意了。 如果后续厂家同意退货就退了，不同意的话就换到京东方屏幕为止。 哎，下次，再也不会买抽奖制的产品了，同样的价钱不同的体验，心累。 最终选择遇见又经过长时间的挑选后，我最终再次锁定了拯救者系列中的Y9000K型号，在这期间我几乎摸遍了市面上的所有笔电，它们都有让我不能接受的缺点，我曾一度想做等等党，可是无意间看到了它，拯救者系列中的旗舰机皇-Y9000K。 我记得第一次见到它 是在一个炎炎夏日的中午，那时的我很燥，感叹到市场上竟没有一款让我心动的笔电。 当无意间看到它的宣传图时，我扫了一遍，找下让我吐槽的点，咦，这个有点不对劲，再仔细盯了几秒后，卧槽，可以啊。 y9000k-poster 网上找了所有的翻车信息后，对我来说 都是一些无关痛痒的缺点。 我突然意识到，我想买的笔电，它来了。 Y9KK，冲冲冲~ 得到由于在当时Y9000K只卖了第一批 Z 码，市面上除了黄牛基本没货。 要等到官方货源 只能 618 抢购，除此之外 别无他法，所以煎熬的狙击开始了。 我分别在淘宝，官网，京东都预约好了商品，并订了 8 个闹钟，做好了法事（内心）。 而在 618 之前官方暴露得知，全国Y9KK丐版只有 600 台，这让我心中一沉，简直是第二个yoga 14s啊，如果抢不到，就只能等到今年下半场的厂商战争了。 不过万幸的是，我在京东居然抢到了有赠品的丐版！我抢到了！ 当时的场景可以说秒没，到0：00后直接显示没货… 而我第一次点击时，也直接提示当地没货，第二次点击才得到货单，谢天谢地。 呃，我今年的欧气全压在这了。 食用到货开机后，第一眼给我的观感是鲜艳，因为Y9KK采用的是广色域屏，让你觉得它的屏幕色彩都能溢出来。 我也是第一次知道 Windows 的红色警告可以这么红，麦克雷的胡子原来是褐色，一直使用的 Solarized Light 主题原来是这种偏黄色… 质感方面 因为全机身金属，可以说 B 格与触感同时拉满。 散热方面 使用的是 VC 液冷，双烤能达到 45w+90w，不算高 但也足够用了。 接口方面 除了常见的接口，还赠了一个雷电三。 … 具体可以去 b 站看一下评测视频，我就不罗嗦了… 总之，给我的感受是真香，可以称得上愉快的购物体验。 评价在我看来，它的优缺点都很鲜明。 优点我就不过多介绍了，上面吹得够可以了，主要说下缺点。 性价比一般。 2020 年 10875H 卖 1w+？怕不是要被 AMD 干死，市面上的 4800H 完全可以与 10875H 一较高下，但价钱却便宜很多。最近 Y7000P 也出了 10875H，价格降到了 8K+… 没货，没货，没货。 品控一般，群里翻车的真的不少，不过我除了一个屏幕坏点外，什么也没遇到。 结束语如果你也有购买笔电的需求，可以随时与我联系，一起讨论~ 转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。","categories":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"换机","slug":"换机","permalink":"https://tomotoes.com/blog/tags/%E6%8D%A2%E6%9C%BA/"}]},{"title":"30s 源码刨析系列之函数篇","date":"2020-03-01T03:43:52.000Z","path":"/30s-javascript-function/","text":"由浅入深、逐个击破 30SecondsOfCode 中函数系列所有源码片段，带你领略源码之美。 前言本系列是对名库 30SecondsOfCode 的深入刨析。 本篇是其中的函数篇，可以在极短的时间内培养你的函数式思维。 内容根据源码的难易等级进行排版，目录如下： 新手级 普通级 专家级 正文新手级checkProp12345678910111213141516171819const checkProp = (predicate, prop) =&gt; obj =&gt; !!predicate(obj[prop]);const lengthIs4 = checkProp(l =&gt; l === 4, 'length');lengthIs4([]); // falselengthIs4([1, 2, 3, 4]); // truelengthIs4(new Set([1, 2, 3, 4])); // false (Set uses Size, not length)const session = { user: {} };const validUserSession = checkProp(u =&gt; u.active &amp;&amp; !u.disabled, 'user');validUserSession(session); // falsesession.user.active = true;validUserSession(session); // trueconst noLength = checkProp(l =&gt; l === undefined, 'length');noLength([]); // falsenoLength({}); // truenoLength(new Set()); // true 作用：检查参数是否存在给定的属性。 解析：给定一个检查函数，和所需检查的属性名，返回一个函数。可通过调用 返回的函数，去判定 传入的对象参数是否符合检查函数。 functionName123const functionName = fn =&gt; (console.debug(fn.name), fn);functionName(Math.max); // max (logged in debug channel of console) 作用：打印函数名。 解析：使用console.debugAPI 和函数的name属性，把 函数类型参数的名字 打印到控制台的 debug channel 中。 negate123const negate = func =&gt; (...args) =&gt; !func(...args);[1, 2, 3, 4, 5, 6].filter(negate(n =&gt; n % 2 === 0)); // [ 1, 3, 5 ] 作用：反转 谓词函数（返回类型为布尔的函数）的返回结果。 解析：假设有一谓词函数为func = args =&gt; bool，我们想要反转其结果，便可对它的调用方式进行进一步的抽象，把反转结果的逻辑放置抽象中。 在本函数中，只需要一个 逻辑非运算符!func(...args)。 而扩展运算符...是对参数的抽象，代表的是传入的所有参数，我们要将所有参数一个不差地传递，不可破环 谓词函数的“纯洁性”。 unary123const unary = fn =&gt; val =&gt; fn(val);['6', '8', '10'].map(unary(parseInt)); // [6, 8, 10] 作用：参数函数调用时 只接受 参数函数的第一个参数，忽略其他参数。 解析：包装一个函数，并不做任何处理：wrap = fn =&gt; (...args) =&gt; fn(...args) 很显然，如果想对传入的参数进行处理，只需对args动刀，而本例直接使用了单独的一个变量，忽略了其他参数。 普通级ary1234const ary = (fn, n) =&gt; (...args) =&gt; fn(...args.slice(0, n));const firstTwoMax = ary(Math.max, 2);[[2, 6, 'a'], [6, 4, 8], [10]].map(x =&gt; firstTwoMax(...x)); // [6, 6, 1 作用：参数函数调用时 只接受 参数函数的前 n 个参数，忽略其他参数。 解析：和上列逻辑如出一辙，只不过处理参数的逻辑换成了...args.slice(0, n)，只要前 n 个。 attempt123456789101112const attempt = (fn, ...args) =&gt; { try { return fn(...args); } catch (e) { return e instanceof Error ? e : new Error(e); }};var elements = attempt(function(selector) { return document.querySelectorAll(selector);}, '&gt;_&gt;');if (elements instanceof Error) elements = []; // elements = [] 作用：对 参数函数 进行异常捕获，如果有异常则抛出。 解析：对 参数函数 进行进一步封装，本例封装的逻辑是try catch，即捕获参数函数的异常。 很久之前，我看到过一个关于java8的 attempt 片段，里面还增加了重试逻辑。 js 实现代码如下: 12345678910const attempt = (fn, ...args, count, bound) =&gt; { try { return fn(...args); } catch (e) { if(count == bound){ return e instanceof Error ? e : new Error(e); } return attempt(fn, ...args, count + 1, bound) }}; bind12345678const bind = (fn, context, ...boundArgs) =&gt; (...args) =&gt; fn.apply(context, [...boundArgs, ...args]);function greet(greeting, punctuation) { return greeting + ' ' + this.user + punctuation;}const freddy = { user: 'fred' };const freddyBound = bind(greet, freddy);console.log(freddyBound('hi', '!')); // 'hi fred!' 作用：原生 API-bind的另一种实现。 fn.bind(context,...args) =&gt; bind(fn,context,...args) MDN 关于 bind 的解释： bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 解析：首先，使用了apply将给定的 上下文参数 应用于 参数函数。 其次，利用 apply 只接受数组作为参数的规定，将最初传入的参数，和后续传入的参数按顺序合并在一个数组中传递进去。 bindKey1234567891011const bindKey = (context, fn, ...boundArgs) =&gt; (...args) =&gt; context[fn].apply(context, [...boundArgs, ...args]);const freddy = { user: 'fred', greet: function(greeting, punctuation) { return greeting + ' ' + this.user + punctuation; }};const freddyBound = bindKey(freddy, 'greet');console.log(freddyBound('hi', '!')); // 'hi fred!' 作用：把上列中的fn换成了context[fn]。 解析：我们原来的 参数函数 变成了一个 上下文参数的一个属性，而将这个属性依附于上下文对象就成了一个函数context[fn]。 可以说，这个一个调用方式特殊的bind。 call123456789const call = (key, ...args) =&gt; context =&gt; context[key](...args);Promise.resolve([1, 2, 3]) .then(call('map', x =&gt; 2 * x)) .then(console.log); // [ 2, 4, 6 ]const map = call.bind(null, 'map');Promise.resolve([1, 2, 3]) .then(map(x =&gt; 2 * x)) .then(console.log); // [ 2, 4, 6 ] 作用：动态改变函数执行的上下文。 解析：给定一个属性参数，再给定一组调用参数，返回一个接受上下文对象的函数，并最终组合调用。 其实这里面暗含了一个约束，很显然，context[key]必须是一个函数。 这个片段本质是对上下文的抽象。举个例子： 1234const filterMen = call('filter', person =&gt; person.sex === 'man')filterMen([{sex:'woman',...},{sex:'man',...},...])// 如果有其他 上下文对象，本例中也就是数组 需要相同的 逻辑过滤呢？ chainAsync1234567891011121314151617181920212223const chainAsync = fns =&gt; { let curr = 0; const last = fns[fns.length - 1]; const next = () =&gt; { const fn = fns[curr++]; fn === last ? fn() : fn(next); }; next();};chainAsync([ next =&gt; { console.log('0 seconds'); setTimeout(next, 1000); }, next =&gt; { console.log('1 second'); setTimeout(next, 1000); }, () =&gt; { console.log('2 second'); }]); 作用：将 函数数组转换为有决策权的链式函数调用。 我为什么称之有决策权的链式函数调用呢？ 因为每个函数都会接受一个 next 方法参数，它代表的就是调用链中的下一个函数，所以什么时候调用下一个函数，要不要调用，决策权在你。 解析：其实这个片段很简单。 首先，fns 类型一个函数数组，其中除了最后一个函数都有隐含的约束，可以选择接受 next 参数。 而 next 参数的含义就是调用链中的下一个函数，说白了 就是数组中的下一个成员。 而最后一个函数是无参函数。 片段中复杂点在于：利用闭包存储了两个关键变量。 第一个是 调用链中的函数游标:curr；第二个是结束标志，最后一个函数:last。 每次链式向下调用前，都会进行一些逻辑处理： 1234const next = () =&gt; { const fn = fns[curr++]; fn === last ? fn() : fn(next);}; 先取出当前游标所在函数，再把游标指向下一个函数。 然后，判断是否是最后一个函数，是则直接调用，结束；反之，传入 next 调用。 如果，你是一个后端开发者，可以把其理解为中间件的工作模式。 collectInto1234567const collectInto = fn =&gt; (...args) =&gt; fn(args);const Pall = collectInto(Promise.all.bind(Promise));let p1 = Promise.resolve(1);let p2 = Promise.resolve(2);let p3 = new Promise(resolve =&gt; setTimeout(resolve, 2000, 3));Pall(p1, p2, p3).then(console.log); // [1, 2, 3] (after about 2 seconds) 作用：将接受数组的函数更改为接受可变参数。 分析：利用了扩展运算符的性质，...args代表的是所有参数组成的数组，然后将这数组传递进去调用。 可别小看了这一片段，调用方式的改变会决定很多上层逻辑。 平常我们大概率都会，建立一个数组，收集所需的异步函数。 在本例中，很明显的看到 从参数为数组类型的约束 中解放了出来。 compose1234567891011const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; f(g(...args)));const substract3 = x =&gt; x - 3;const add5 = x =&gt; x + 5;const multiply = (x, y) =&gt; x * y;const multiplyAndAdd5AndSubstract3 = compose( substract3, add5, multiply);multiplyAndAdd5AndSubstract3(5, 2); // 12 作用：将传入的多个[异步]函数以组合的方式 调用。 先将参数传入最后一个[异步]函数，然后将得到的结果，传入倒数第二个[异步]函数，以此类推。 compose可以说是函数式编程的经典片段。 它的具体意义可以说是逻辑分层。像洋葱一样，一层一层地处理数据。 解析：fns 代表的是 传入的多个函数 组成的数组。 利用reduce方法实现函数的“洋葱”包裹。 因为这种逻辑语义表示效果不好，就直接上上面例子的代码流程了。 12345678910111213141516reduce 第一次循环:f: substract3; g: add5; 返回结果：(...args) =&gt; substract3(add5(...args));reduce 第二次循环：f: (...args) =&gt; substract3(add5(...args)); g: multiply; 返回结果：(...args1) =&gt; ((...args2) =&gt; substract3(add5(...args2)))(multiply(...args1))优化后:(...args) =&gt; substract3(add5(multiply(...args)));循环下去，以此类推...最后的返回的形式：(...args) =&gt; 第一个函数(第二个函数(第三个函数(...最后一个函数(...args)))) PS: 说实话，我并不喜欢 compose，在上例中就可以很明显的看到缺点。 把很多函数组合起来，第一是缺少语义化，与之对应的例子就是 Promise 的 then 调用链，语义鲜明； 第二是无法添加函数与函数之间的抽象逻辑，只能一次写好。 第三是各个函数之间存在隐含的参数约束，很可怕的。 composeRight1234567const composeRight = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; g(f(...args)));const add = (x, y) =&gt; x + y;const square = x =&gt; x * x;const substract3 = x =&gt; x - 3;const addAndSquare = composeRight(add, square,substract3);addAndSquareAndSubstract3(1, 2); // 6 作用：将传入的多个[异步]函数以组合的方式 调用。 先将参数传入第一个[异步]函数，然后将得到的结果，传入第二个[异步]函数，以此类推。 converge1234567const converge = (converger, fns) =&gt; (...args) =&gt; converger(...fns.map(fn =&gt; fn.apply(null, args)));const average = converge((a, b) =&gt; a / b, [ arr =&gt; arr.reduce((a, v) =&gt; a + v, 0), arr =&gt; arr.length]);average([1, 2, 3, 4, 5, 6, 7]); // 4 作用：将 函数数组的返回结果 传递到converger函数，进一步处理，可用作分析统计。 解析: 使用map 和apply将参数数据传递给每个处理函数，并将处理后的结果交给converger函数。 curry12345const curry = (fn, arity = fn.length, ...args) =&gt; arity &lt;= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);curry(Math.pow)(2)(10); // 1024curry(Math.min, 3)(10)(50)(2); // 2 作用：函数柯里化。 柯里化不管在是函数式思维的理解，还是现实面试中，都非常的重要。 维基百科上 柯里化的解释： 把接受多个参数)的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数 解析：这个bind用得真是神了，借助它积累每次传进来的参数，等到参数足够时，再调用。 debounce123456789101112131415const debounce = (fn, ms = 0) =&gt; { let timeoutId; return function(...args) { clearTimeout(timeoutId); timeoutId = setTimeout(() =&gt; fn.apply(this, args), ms); };};window.addEventListener( 'resize', debounce(() =&gt; { console.log(window.innerWidth); console.log(window.innerHeight); }, 250)); // Will log the window dimensions at most every 250ms 作用：函数防抖。 什么是防抖和节流？有什么区别？如何实现？ 一文中关于防抖解释： 触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间。 同样，防抖也是面试必考的点。 解析: 传入需防抖的函数，和防抖的时间间隔，返回一个已防抖化的函数。 主要借助setTimeout和function + apply保存上下文完成。 每次调用函数前，都执行一遍clearTimeout，保证重新计算调用时间。 无论是调用多么频繁的函数都会在指定时间的间隔后只运行一次。 defer123456789const defer = (fn, ...args) =&gt; setTimeout(fn, 1, ...args);// Example A:defer(console.log, 'a'), console.log('b'); // logs 'b' then 'a'// Example B:document.querySelector('#someElement').innerHTML = 'Hello';longRunningFunction(); // Browser will not update the HTML until this has finisheddefer(longRunningFunction); // Browser will update the HTML then run the function 作用：推迟调用函数，直到清除当前调用堆栈。 可适用于推迟 cpu 密集型计算，以免阻塞渲染引擎工作。 分析：使用setTimeout（超时时间为 1ms）将 函数参数 添加到浏览器事件队列末尾。 因为 JavaScript 是单线程执行，先是主线程执行完毕，然后在读取事件队列中的代码执行。 如果主线程有运行时间太长的函数，会阻塞页面渲染，所以将其放置到事件队列。 delay123456789const delay = (fn, wait, ...args) =&gt; setTimeout(fn, wait, ...args);delay( function(text) { console.log(text); }, 1000, 'later'); // Logs 'later' after one second. 作用：延迟函数执行。 是的，它和defer非常像，但使用场景却是不一样。 defer 的目的是将占据主线程时间长的函数推迟到事件队列。 而 delay 只是字面意思，延迟执行。 解析：对 setTimeout 进行语义化封装。 flip123456789const flip = fn =&gt; (first, ...rest) =&gt; fn(...rest, first);let a = { name: 'John Smith' };let b = {};const mergeFrom = flip(Object.assign);let mergePerson = mergeFrom.bind(null, a);mergePerson(b); // == bb = {};Object.assign(b, a); // == b 作用：对 参数函数 的输入数据进行进一步处理，将数据的第一个参数与其余参数位置对调。 解析：主要利用 扩展运算符的性质，对参数的位置进行调整。 如果你不了解这一语言特性，可参考阮一峰老师的ES6 入门。 hz12345678910111213141516171819202122const hz = (fn, iterations = 100) =&gt; { const before = performance.now(); for (let i = 0; i &lt; iterations; i++) fn(); return (1000 * iterations) / (performance.now() - before);};// 10,000 element arrayconst numbers = Array(10000) .fill() .map((_, i) =&gt; i);// Test functions with the same goal: sum up the elements in the arrayconst sumReduce = () =&gt; numbers.reduce((acc, n) =&gt; acc + n, 0);const sumForLoop = () =&gt; { let sum = 0; for (let i = 0; i &lt; numbers.length; i++) sum += numbers[i]; return sum;};// `sumForLoop` is nearly 10 times fasterMath.round(hz(sumReduce)); // 572Math.round(hz(sumForLoop)); // 4784 作用：返回函数每秒执行一次的次数。 hz 是赫兹的单位（频率的单位）定义为每秒一个周期。 解析：通过两次使用performance.now获取iterations次迭代前后的毫秒差。 然后将毫秒转换为秒并除以经过的时间，可以得到每秒的函数执行次数。 PS: 此处，并没有太好的个人理解，翻译自官方。 once12345678910111213const once = fn =&gt; { let called = false; return function(...args) { if (called) return; called = true; return fn.apply(this, args); };};const startApp = function(event) { console.log(this, event); // document.body, MouseEvent};document.body.addEventListener('click', once(startApp)); // only runs `startApp` once upon click 作用：确保一个函数只被调用一次。 分析：因为 JavaScript 是单线程执行环境，不需要考虑并发环境，直接一个内部变量存到闭包中，每次调用前判断，并在第一次调用时，修改其值，让后续调用全部失效。 给你看一下 Go 的 once，官方是通过atomic库实现的： 12345678910111213141516171819202122package syncimport ( \"sync/atomic\")type Once struct { m Mutex done uint32}func (o *Once) Do(f func()) { if atomic.LoadUint32(&amp;o.done) == 1 { return } o.m.Lock() defer o.m.Unlock() if o.done == 0 { defer atomic.StoreUint32(&amp;o.done, 1) f() }} over1234const over = (...fns) =&gt; (...args) =&gt; fns.map(fn =&gt; fn.apply(null, args));const minMax = over(Math.min, Math.max);minMax(1, 2, 3, 4, 5); // [1,5] 作用：利用函数数组，对接下来的输入数据进行处理，得到每个函数处理后的结果数组。 解析：使用map和apply将输入的数据传递到每个函数中进行处理。 overArgs123456const overArgs = (fn, transforms) =&gt; (...args) =&gt; fn(...args.map((val, i) =&gt; transforms[i](val)));const square = n =&gt; n * n;const double = n =&gt; n * 2;const fn = overArgs((x, y) =&gt; [x, y], [square, double]);fn(9, 3); // [81, 6] 作用：利用 transforms 函数数组，分别处理相应位置的输入数据，并把结果传递进给定函数。 解析：transforms 函数数组 和参数必须位置对应，这个约束有点强啊。 partial12345const partial = (fn, ...partials) =&gt; (...args) =&gt; fn(...partials, ...args);const greet = (greeting, name) =&gt; greeting + ' ' + name + '!';const greetHello = partial(greet, 'Hello');greetHello('John'); // 'Hello John!' 作用：将调用函数的数据分为两次输入，并按正序调用。 解析：两次使用扩展运算符（…），保存不同时期的数据，最后调用。 partialRight12345const partialRight = (fn, ...partials) =&gt; (...args) =&gt; fn(...args, ...partials);const greet = (greeting, name) =&gt; greeting + ' ' + name + '!';const greetJohn = partialRight(greet, 'John');greetJohn('Hello'); // 'Hello John!' 作用：将调用函数的数据分为两次输入，并按反序调用。 解析：两次使用扩展运算符（…），保存不同时期的数据，最后调用。 pipeAsyncFunctions1234567891011const pipeAsyncFunctions = (...fns) =&gt; arg =&gt; fns.reduce((p, f) =&gt; p.then(f), Promise.resolve(arg));const sum = pipeAsyncFunctions( x =&gt; x + 1, x =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(x + 2), 1000)), x =&gt; x + 3, async x =&gt; (await x) + 4);(async () =&gt; { console.log(await sum(5)); // 15 (after one second)})(); 作用：将传入的多个[异步]函数按照正序 依次调用。 解析：结合reduce和Promise.then，将数据按照正序传递到每个[异步]函数,进行处理，处理的结果又传给下一个[异步]函数，以此类推。 promisify1234567const promisify = func =&gt; (...args) =&gt; new Promise((resolve, reject) =&gt; func(...args, (err, result) =&gt; (err ? reject(err) : resolve(result))) );const delay = promisify((d, cb) =&gt; setTimeout(cb, d));delay(2000).then(() =&gt; console.log('Hi!')); // // Promise resolves after 2s 作用：将回调函数改为Promise方式处理结果。 在 Node8+ ，你可以使用util.promisify 解析：首先接受给定的回调函数，然后直接在 Promise 中调用该函数。 因为回调函数的结果按照规范永远是最后一个参数，我们只需要在函数调用时，把最后一个参数换成 Promise 的方式，即：如果回调函数出现错误则 reject，反之 resolve。 注意：被 promisify 的函数必须接受回调参数且后续会调用。 rearg123456789const rearg = (fn, indexes) =&gt; (...args) =&gt; fn(...indexes.map(i =&gt; args[i]));var rearged = rearg( function(a, b, c) { return [a, b, c]; }, [2, 0, 1]);rearged('b', 'c', 'a'); // ['a', 'b', 'c'] 作用：根据指定的索引重新排列传入的参数。 解析：利用map结合扩展运算符，重新排列传入的参数，并将转换后的参数传递给 fn。 runPromisesInSeries12345const runPromisesInSeries = ps =&gt; ps.reduce((p, next) =&gt; p.then(next), Promise.resolve());const delay = d =&gt; new Promise(r =&gt; setTimeout(r, d));runPromisesInSeries([() =&gt; delay(1000), () =&gt; delay(2000)]); // Executes each promise sequentially, taking a total of 3 seconds to complete 作用：按照正序 运行给定的多个返回类型为 Promise 函数。 解析：使用reduce创建一个 Promise 链，每次运行完一个传入的 Promise，都会返回最外部的Promise.then，从而进行下一次调用。 sleep1234567const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));async function sleepyWork() { console.log(\"I'm going to sleep for 1 second.\"); await sleep(1000); console.log('I woke up after 1 second.');} 作用: 延迟异步函数的执行。 解析：创建一个接受毫秒数的函数，并结合setTimeout，在给定的毫秒数后，返回一个resolve状态的 Promise。 使用场景：利用异步函数的“同步”机制(await)，使其在异步函数中达到“睡眠”的效果。 spreadOver1234const spreadOver = fn =&gt; argsArr =&gt; fn(...argsArr);const arrayMax = spreadOver(Math.max);arrayMax([1, 2, 3]); // 3 作用：将接受可变参数的函数更改为接受数组。 如果你认真读了文章，就会发现这是collectInto函数的反模式。 分析：利用了扩展运算符的性质，将传递进来的数组解构再交给处理函数。 times12345678const times = (n, fn, context = undefined) =&gt; { let i = 0; while (fn.call(context, i) !== false &amp;&amp; ++i &lt; n) {}};var output = '';times(5, i =&gt; (output += i));console.log(output); // 01234 作用：将给定的函数，迭代执行 n 次。 分析：使用Function.call迭代调用给定的函数，并把迭代的次数传进函数第一个参数。 如果函数返回 false 可提前退出。 uncurry123456789const uncurry = (fn, n = 1) =&gt; (...args) =&gt; { const next = acc =&gt; args =&gt; args.reduce((x, y) =&gt; x(y), acc); if (n &gt; args.length) throw new RangeError('Arguments too few!'); return next(fn)(args.slice(0, n));};const add = x =&gt; y =&gt; z =&gt; x + y + z;const uncurriedAdd = uncurry(add, 3);uncurriedAdd(1, 2, 3); // 6 作用：函数反柯里化。 柯里化是将接受多个参数)的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。 而反柯里化就是将多个接受参数的层层函数，铺平。 解析：反柯里化的关键代码在于 args.reduce((x, y) =&gt; x(y), acc)。 123456789101112131415在上例中,args: [1,2,3]acc: x =&gt; y =&gt; z =&gt; x + y + z第一次循环：x：x =&gt; y =&gt; z =&gt; x + y + zy：1返回结果：y =&gt; z =&gt; 1 + y + z第二次循环:x: y =&gt; z =&gt; 1 + y + zy: 2返回结果：z =&gt; 1 + 2 + z最后一次循环的结果，即 1 + 2 +3 可以看出，每次一循环，都会利用闭包”填充”一个所需变量。 返回的结果分为两种情况： 一是 一个保留了 n 个前置参数的函数。 二是层叠函数中最后一个函数的返回结果。 值得一提的是，在源码中使用了slice(0，n)保留适当数量的参数。 如果提供的参数的个数小于给定的解析长度，就会抛出错误。 unfold123456789const unfold = (fn, seed) =&gt; { let result = [], val = [null, seed]; while ((val = fn(val[1]))) result.push(val[0]); return result;};var f = n =&gt; (n &gt; 50 ? false : [-n, n + 10]);unfold(f, 10); // [-10, -20, -30, -40, -50] 作用：使用种子值以及特殊的数据存储与迭代方式构建一个数组。 解析: 我为什么说数据存储与迭代方式很特殊呢？ 迭代的变量与结果值，保存在同一数组里，用 01 下标区分。 而迭代的函数，也需要满足这一规范，返回同样的数组[value，nextSeed]，保证下一次迭代，或者返回 false 终止过程。 when12345const when = (pred, whenTrue) =&gt; x =&gt; (pred(x) ? whenTrue(x) : x);const doubleEvenNumbers = when(x =&gt; x % 2 === 0, x =&gt; x * 2);doubleEvenNumbers(2); // 4doubleEvenNumbers(1); // 1 作用：根据pred函数测试给定数据。如结果为真，则执行whenTrue函数；反之，返回数据。 解析: 我喜欢语义化的封装，可大幅提升代码的可读性，减少逻辑负担。 专家级memoize1234567891011121314const memoize = fn =&gt; { const cache = new Map(); const cached = function(val) { return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) &amp;&amp; cache.get(val); }; cached.cache = cache; return cached;};// See the `anagrams` snippet.const anagramsCached = memoize(anagrams);anagramsCached('javascript'); // takes a long timeanagramsCached('javascript'); // returns virtually instantly since it's now cachedconsole.log(anagramsCached.cache); // The cached anagrams map 作用：为给定的函数添加缓存功能。 解析: 通过实例化一个新的Map对象来创建一个空的缓存。 并对函数的调用进一步的封装，如果调用时，传入了一个之前已经传递过的参数，将从缓存中直接返回结果，执行时间为 O(1)；如果是首次传递，则需运行函数，将得到结果缓存，并返回。 其实，我们还可以借助这个片段，看到一丝 JavaScript 语法的残缺。 到目前为止，一个社区公认的私有属性语法都没有，TC39 一直提议用#号，并阐述了很多原因、声明。 哎，说白了，就是 JavaScript 从一开始设计的失误，到现在已经无法挽回了。 throttle12345678910111213141516171819202122232425262728const throttle = (fn, wait) =&gt; { let inThrottle, lastFn, lastTime; return function() { const context = this, args = arguments; if (!inThrottle) { fn.apply(context, args); lastTime = Date.now(); inThrottle = true; } else { clearTimeout(lastFn); lastFn = setTimeout(function() { if (Date.now() - lastTime &gt;= wait) { fn.apply(context, args); lastTime = Date.now(); } }, Math.max(wait - (Date.now() - lastTime), 0)); } };};window.addEventListener( 'resize', throttle(function(evt) { console.log(window.innerWidth); console.log(window.innerHeight); }, 250)); // Will log the window dimensions at most every 250ms 作用: 函数节流。 什么是防抖和节流？有什么区别？如何实现？ 一文中关于防抖解释： 高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率。 同样，节流也是面试必考的点。 解析：第一次执行时，立即执行给定函数，保存当前的时间，并设置标记变量。 标记变量主要用于判断是否第一次调用，如果是第一次则立刻运行。 反之不是第一次运行，过了等待的毫秒后才可继续运行。 主要逻辑是每次运行前先清除上一个的定时器，然后计算出上一次运行的时间与给定的运行间隔所差的毫秒数，并利用其数据新建一个定时器运行。 定时器里的函数除了调用给定函数，还会更新上一次运行的时间变量。 节流的实现，网上的文章有很多版本，但多少都有点瑕疵。 结束语呼，花了很长的时间，终于搞定了这篇文章。 以后的 30s 源码刨析系列会挑选一些源码片段去解析，而不是针对某一分类了。 本篇文章涉及了我的一些思考，希望能对你有帮助。 转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。 .post-toc{overflow-y: auto; overflow-x: hidden; height: 35em;}","categories":[{"name":"源码","slug":"源码","permalink":"https://tomotoes.com/blog/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://tomotoes.com/blog/tags/%E6%BA%90%E7%A0%81/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tomotoes.com/blog/tags/JavaScript/"},{"name":"函数式","slug":"函数式","permalink":"https://tomotoes.com/blog/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"}]},{"title":"手撸一个静态文档生成器[译]","date":"2020-02-29T04:05:44.000Z","path":"/build-static-site-generator-nodejs/","text":"目前有很多优秀的静态文档生成器，它们的工作原理比你想象的要简单得多。 前言原文: Build a static site generator in 40 lines with Node.js 作者: Douglas Matoso 翻译许可: image img 为什么要造这个轮子当我计划建立个人网站时，我的需求很简单，做一个只有几个页面的网站，放置一些关于自己的信息，我的技能和项目就够了。 毫无疑问，它应该是纯静态的(不需要后端服务，可托管在任何地方)。 我曾经使用过Jekyll, Hugo和Hexo这些知名的静态文档生成器，但我认为它们有太多的功能，我不想为我的网站增加这么多的复杂性。 所以我觉得，针对我的需求，一个简单的静态文档生成器就可以满足。 嗯，手动构建一个简单的生成器，应该不会那么难。 正文需求分析这个生成器必须满足以下条件： 从EJS模板生成HTML文件。 具有布局文件，所有页面都应该具有相同的页眉，页脚，导航等。 允许可重用布局组件。 站点的大致信息封装到一个配置文件中。 从 JSON 文件中读取数据。 例如：项目列表，这样我可以轻松地迭代和构建项目页面。 为什么使用 EJS 模板? 因为 EJS 很简单，它只是嵌入在 HTML 中的 JavaScript 而已。 项目结构12345678public/ src/ assets/ data/ pages/ partials/ layout.ejs site.config.js public: 生成站点的位置。 src: 源文件。 src/assets: 包含 CSS, JS, 图片 等 src/data: 包含 JSON 数据。 src/pages: 根据其中的 EJS 生成 HTML 页面的模板文件夹。 src/layout.ejs: 主要的原页面模板，包含特殊&lt;%-body%&gt;占位符，将插入具体的页面内容。 site.config.js: 模板中全局配置文件。 生成器生成器代码位于scripts/build.js文件中，每次想重建站点时，执行npm run build命令即可。 实现方法是将以下脚本添加到package.json的scripts块中： 1\"build\": \"node ./scripts/build\" 下面是完整的生成器代码： 1234567891011121314151617181920212223242526272829303132333435363738394041const fse = require('fs-extra')const path = require('path')const { promisify } = require('util')const ejsRenderFile = promisify(require('ejs').renderFile)const globP = promisify(require('glob'))const config = require('../site.config')const srcPath = './src'const distPath = './public'// clear destination folderfse.emptyDirSync(distPath)// copy assets folderfse.copy(`${srcPath}/assets`, `${distPath}/assets`)// read page templatesglobP('**/*.ejs', { cwd: `${srcPath}/pages` }) .then((files) =&gt; { files.forEach((file) =&gt; { const fileData = path.parse(file) const destPath = path.join(distPath, fileData.dir) // create destination directory fse.mkdirs(destPath) .then(() =&gt; { // render page return ejsRenderFile(`${srcPath}/pages/${file}`, Object.assign({}, config)) }) .then((pageContents) =&gt; { // render layout with page contents return ejsRenderFile(`${srcPath}/layout.ejs`, Object.assign({}, config, { body: pageContents })) }) .then((layoutContent) =&gt; { // save the html file fse.writeFile(`${destPath}/${fileData.name}.html`, layoutContent) }) .catch((err) =&gt; { console.error(err) }) }) }) .catch((err) =&gt; { console.error(err) }) 接下来，我将解释代码中的具体组成部分。 依赖我们只需要三个依赖项： ejs 把我们的模板编译成HTML。 fs-extra Node 文件模块的衍生版，具有更多的功能，并增加了Promise的支持。 glob 递归读取目录，返回包含与指定模式匹配的所有文件，类型是数组。 Promisify我们使用Node提供的util.promisify将所有回调函数转换为基于Promise的函数。 它使我们的代码更短，更清晰，更易于阅读。 123const { promisify } = require('util') const ejsRenderFile = promisify(require('ejs').renderFile) const globP = promisify(require('glob')) 加载配置在顶部，我们加载站点配置文件，以稍后将其注入模板渲染中。 1const config = require('../site.config') 站点配置文件本身会加载其他JSON数据，例如： 123456789const projects = require('./src/data/projects')module.exports = { site: { title: 'NanoGen', description: 'Micro Static Site Generator in Node.js', projects } } 清空站点文件夹我们使用fs-extra提供的emptyDirSync函数清空 生成后的站点文件夹。 1fse.emptyDirSync(distPath) 拷贝静态资源我们使用fs-extra提供的copy函数，该函数以递归方式复制静态资源 到站点文件夹。 1fse.copy(`${srcPath}/assets`, `${distPath}/assets`) 编译页面模板首先我们使用glob（已被 promisify）递归读取src/pages文件夹以查找.ejs文件。 它将返回一个匹配给定模式的所有文件数组。 12globP('**/*.ejs', { cwd: `${srcPath}/pages` }) .then((files) =&gt; { 对于找到的每个模板文件，我们使用Node的path.parse函数来分隔文件路径的各个组成部分（例如目录，名称和扩展名）。 然后，我们在站点目录中使用fs-extra提供的mkdirs函数创建与之对应的文件夹。 123456files.forEach((file) =&gt; { const fileData = path.parse(file) const destPath = path.join(distPath, fileData.dir) // create destination directory fse.mkdirs(destPath) 然后，我们使用EJS编译文件，并将配置数据作为数据参数。 由于我们使用的是已 promisify 的ejs.renderFile函数，因此我们可以返回调用结果，并在下一个promise链中处理结果。 1234.then(() =&gt; { // render page return ejsRenderFile(`${srcPath}/pages/${file}`, Object.assign({}, config)) }) 在下一个then块中，我们得到了已编译好的页面内容。 现在，我们编译布局文件，将页面内容作为body属性传递进去。 1234.then((pageContents) =&gt; { // render layout with page contents return ejsRenderFile(`${srcPath}/layout.ejs`, Object.assign({}, config, { body: pageContents })) }) 最后，我们得到了生成好的编译结果（布局+页面内容的 HTML），然后将其保存到对应的HTML文件中。 1234.then((layoutContent) =&gt; { // save the html file fse.writeFile(`${destPath}/${fileData.name}.html`, layoutContent) }) 调试服务器为了使查看结果更容易，我们在package.json的scripts中添加一个简单的静态服务器。 1\"serve\": \"serve ./public\" 运行 npm run serve 命令，打开http://localhost:5000就看到结果了。 进一步探索Markdown大多数静态文档生成器都支持以Markdown格式编写内容。 并且，它们还支持以YAML格式在顶部添加一些元数据，如下所示： 1234--- title: Hello World date: 2013/7/13 20:46:25 --- 只需要一些修改，我们就可以支持相同的功能了。 首先，我们必须增加两个依赖: marked 将markdown编译为HTML front-matter 从markdown中提取元数据(front matter)。 然后，我们将glob的匹配模式更新为包括.md文件，并保留.ejs，以支持渲染复杂页面。 如果想要部署一些纯 HTML 页面，还需包含.html。 1globP('**/*.@(md|ejs|html)', { cwd: `${srcPath}/pages` }) 对于每个文件，我们都必须加载文件内容，以便可以在顶部提取到元数据。 1234.then(() =&gt; { // read page file return fse.readFile(`${srcPath}/pages/${file}`, 'utf-8') }) 我们将加载后的内容传递给front-matter。 它将返回一个对象，其中attribute属性便是提取后的元数据。 然后，我们使用此数据扩充站点配置。 1234.then((data) =&gt; { // extract front matter const pageData = frontMatter(data) const templateConfig = Object.assign({}, config, { page: pageData.attributes }) 现在，我们根据文件扩展名将页面内容编译为 HTML。 如果是.md，则利用marked函数编译; 如果是.ejs，我们继续使用EJS编译; 如果是.html，便无需编译。 123456789101112let pageContent switch (fileData.ext) { case '.md': pageContent = marked(pageData.body) break case '.ejs': pageContent = ejs.render(pageData.body, templateConfig) break default: pageContent = pageData.body } 最后，我们像以前一样渲染布局。 增加元数据，最明显的一个意义是，我们可以为每个页面设置单独的标题，如下所示： 123--- title: Another Page --- 并让布局动态地渲染这些数据： 1&lt;title&gt;&lt;%= page.title ? `${page.title} | ` : '' %&gt;&lt;%= site.title %&gt;&lt;/title&gt; 如此一来，每个页面将具有唯一的&lt;title&gt;标签。 多种布局的支持另一个有趣的探索是，在特定的页面中使用不同的布局。 比如专门为站点首页设置一个独一无二的布局： 123--- layout: minimal --- 我们需要有单独的布局文件，我将它们放在src/layouts文件夹中： 123src/layouts/ default.ejs mininal.ejs 如果front matter出现了布局属性，我们将利用layouts文件夹中同名模板文件进行渲染; 如果未设置，则利用默认模板渲染。 12345const layout = pageData.attributes.layout || 'default'return ejsRenderFile(`${srcPath}/layouts/${layout}.ejs`, Object.assign({}, templateConfig, { body: pageContent })) 即使添加了这些新特性，构建脚本也才只有60行。 下一步如果你想更进一步，可以添加一些不难的附加功能： 可热重载的调试服务器 你可以使用像live-server (内置自动重新加载) 或 chokidar (观察文件修改以自动触发构建脚本）这样的模块去完成。 自动部署 添加脚本以将站点部署到GitHub Pages等常见的托管服务，或仅通过SSH（使用scp或rsync等命令）将文件上传到你自己的服务器上。 支持 CSS/JS 预处理器 在静态文件被复制到站点文件前，增加一些预处理器(SASS 编译为 CSS,ES6 编译为 ES5 等)。 更好的日志打印 添加一些 console.log 日志输出 来更好地分析发生了什么。 你可以使用chalk包来完善这件事。 反馈？ 有什么建议吗？ 请随时发表评论或与我联系！ 结束语这个文章的完整示例可以在这里找到：https://github.com/doug2k1/nanogen/tree/legacy。 一段时间后，我决定将项目转换为CLI模块，以使其更易于使用，它位于上面链接的master分支中。 译者： 今日本想写一篇ants(一个高性能的goroutine池)源码解析，奈何环境太吵，静不下心，遂罢。 这是一篇我前些日子无意间看到的文章，虽然是17年的文章，在读完之后仍对我产生了一些思考。 希望这篇文章对你有所帮助。 转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。","categories":[{"name":"后端","slug":"后端","permalink":"https://tomotoes.com/blog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://tomotoes.com/blog/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://tomotoes.com/blog/tags/Nodejs/"},{"name":"译文","slug":"译文","permalink":"https://tomotoes.com/blog/tags/%E8%AF%91%E6%96%87/"}]},{"title":"如何优雅地写博客","date":"2020-01-24T03:34:00.000Z","path":"/how-to-blog-elegantly/","text":"分享我的写作经历。 前言本文将以我个人写作方式的演变为主线，分三个不同的阶段讲述。 请注意：文章的重点不在于 静态文档生成器，写作平台的选择。 正文安逸的 PC 阶段初识 Hexo在大二刚开学的时候，我便萌生了建立个人博客的念头。 当查阅很多资料后，发现了一款名叫Hexo的静态文档生成器广受好评，网上有关的文章也非常多，于是在大势所趋下，我走上了这漫长的建站之路。 这里闲话两句： 刚开始，我把大量的时间都用在网页交互上，现在回头一想，真是搞错了重点。 对于一个博客来说，内容才是最重要的。 CI 的增持在最初的写作流程很繁琐，主要分为下面几个步骤： 调用Hexo命令新建文章 启动Hexo的本地服务器 编写好文章 在本地服务器上检查是否有遗漏 利用Hexo生成出站点网页 将这些网页push到Github Page上 很容易看出，在PC阶段，与写作无关的流程会浪费不少时间，写作效率很难得到保障。 在无关流程中，第五步骤 生成网页是最占据时间的。 所以，我根据需求进一步为博客加了上持续集成工具。 由于我的博客是私有仓库，大部分的CI工具都是收费的。 迫不得已，我使用了Gitlab，不论项目是private或public，一个月都免费提供 2000 次持续集成，这对一个不常更新的博客来说，足矣。 后续：现在CI工具已选为GithubAction。 其对于私有仓库，一个月免费提供 2000 分钟会话，并且构建速度比Gitlab快 5 倍左右。 So，在持续集成的增持之后，我的写作流程简化成了如下： 调用Hexo命令新建文章 启动Hexo的本地服务器 编写好文章 在本地服务器上检查是否有遗漏 直接将项目push到Gitlab 如此一来，将部署阶段彻底隔离。 Typora-所见即所得在PC上我的写作软件是Typora，所见即所得，简单好用。 typora-theme-tomotoes 上图是我根据Tomotoes样式打磨的一款Typora主题 已开源，欢迎使用。 虽然PC上写作很安逸，但可惜的是，对于一个没有固定自习位置的学生来说，PC的不易携带性会被逐渐放大，一场潜在的变革 在所难免。 极致的 Android 阶段在大三之后，因忙于考试，我的学习设备从沉重的笔记本换成了Android手机。 这方便是方便了，可如何写博客呢？这成了一个难题。 在这个阶段，每当有idea来时，也只能记在本上。 虽说解决了基本需求，但 一纸一笔是很难分享于众的。 对于我来说，这还远远不够。 我曾听说过一句话： 现代人的知识库会因互联网的出现而无限增加。 即，你解决不了的事情，Google就是了。 遗失的神器-Termux很快的，在Google的帮忙下，我找到了我想要的答案—Termux（手机上的Shell）。 termux 哈哈，乍一看 是不是很强大！ 我给它安装了zsh，hexo等一系列软件，并且还配置了桌面化程序。 在我看来，PC上所有的需求几乎都可以实现，称得上一个小型操作系统了。 不过，Termux有个坑。 如果你的Android没有root，它是不支持访问内部文件系统的。 即，外部软件编写好的博文，无法同步到Termux里。 如果刷机root会浪费很长时间，我采取的是软连接+npm钩子临时复制删除的方法。 1234567{ \"scripts\": { \"preci\":\"rm -rf ~/blog/source/_posts &amp;&amp; cp -r ~/storage/dcim/_posts ~/blog/source\", \"ci\": \"git add -A &amp;&amp; git commit -am'add new post' &amp;&amp; git push -f gitlab master\", \"postci\": \"rm -rf ~/blog/source/_posts &amp;&amp; ln -s ~/storage/dcim/_posts ~/blog/source/_posts\" }} 如有进一步的问题，请留言。 码字的进一步思考虽说，Android上有如此极客风格的神器，但在写作软件的生态，却差强人意。 在我几乎找遍了Play商店中所有的写作软件之后，我只看上了一款叫做Epsilon Notes的软件。 然而，在后续发展中，一个致命问题显现了出来：手机上码字的体验真的是次到爆！ 原本我还想写一篇文章：《你浪费了一部手机》，看来是我想错了。 输入外设的硬伤，写作的冲动都被浇灭了。 优雅的 iPad 阶段虽然，在上一篇文章中我吐槽了Apple的作风，但这丝毫不影响我对Apple设备的喜爱，生态闭环的极致便是设备体检的极致。 哈哈，本文正式开始了。 iPad 本文，就是在这些工具的加持下完成的。 下面主要讲述这些工具。 Logitech K380在键盘方面，我下了不少功课，最终选择的是罗技的K380键盘。 因为，之前码字主要在笔记本上，所以 短间距，剪刀式的键盘，我用起来很顺手。 并且值得一提的是，该键盘很轻便，方便携带，可谓是出家旅行的必备之物。 Working Copy working-copy 以Apple的喜欢筑墙的性格，终端模拟器是不可能出现在苹果商店里的。 但在Testflight，我还找到了一个类似于Termux的软件—ish。 这款软件唯一的缺点就是没有优点，连安装个node都几经失败，我果断弃坑。 几经辗转，我幸运地遇到了Working Copy，IOS平台上最强大的Git客户端。 现在我写一篇博文，只需要将pull下来的博客，添加上写好的文章再push上去即可。 并且这一切，在Woking Copy中只需要点几下按钮，真的是将所有流程都简化到极致。 可惜的是，Working Copy的价格不便宜-128 元，它只提供 10 天的免费试用。 但如果你能通过Github学生认证的话，Working Copy还是可以继续使用的😄。 iA Writer如果你想问我，IOS端有没有值得推荐的写作软件？ 那很抱歉，这个问题 我无法回答。 在经过数天的寻找之后，我放弃了。 这些知名软件，真的是一个能打的都没有。 目前，我的折中方案是使用iA Writer，相当于简易版的Typora， 它有个神器功能—可直接打开Working Copy中的Github仓库进行编辑。 也就是说，我建博文，写博客这些流程全在这一个软件中就可以搞定。 明显的缺点是，对于图片 还要使用Working Copy进行导入，有那么一丝破环沉浸感。 完美的 CMS 阶段CMS？静态博客还想要什么自行车🚴‍♀️。 困就一个字，溜了溜了。 结束语这就是我的写作经历，希望对你有所帮助。 最后，新年快乐。 转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。","categories":[{"name":"博客","slug":"博客","permalink":"https://tomotoes.com/blog/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://tomotoes.com/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"写作","slug":"写作","permalink":"https://tomotoes.com/blog/tags/%E5%86%99%E4%BD%9C/"}]},{"title":"Apple 一家建筑公司","date":"2020-01-22T06:24:00.000Z","path":"/apple-a-construction-company/","text":"我与墙的故事。 前言本文只从技术发展角度出发，资本层面不允置评。 正文筑墙的公司如果一家公司有自研的操作系统，有完善的设备生态，并且还拥有一大批成千上万的粉丝用户，那么很可能会发生一个现象：墙的出现。 我说的墙指的是，如果你想在我的圈子牟利，你必须遵守我的规矩，必须用我提供的工具，且必须维护我的利益。 这样的一堵墙不仅束缚了开发者，无形中还阻碍了它自身的发展。 Apple，正是一家喜欢筑墙的公司。 我的经历这两天，我针对网站在平板上的显示问题，特地去调整了一下Tomotoes的样式。 结果便陷入了与墙的对抗之中。 第一堵墙我遇到的第一堵墙是Apple专有的浏览器内核。 因为Tomototes在平板下存在层叠渲染 Bug，我单纯地以为只是Safari的问题，结果当下载了好多个浏览器之后，惊奇地发现：网站显示的问题居然一致。 不管了Firefox还是Chrome全是一个样，惊了。 于是我上网搜了一下Apple的浏览器内核信息。 apple only have a webkit 信息很明显：我Apple商店中的所有浏览器都必须用我的内核，你们做的只是UI。 So，那接下来和这一个内核打交道就是了。 第二堵墙我遇到的第二堵墙是苹果浏览器内核的实现标准的任意性。 原本，我想写的文章是 Safari-下一个 IE6，但针对性不强就改了。 在CSS有一个专门指定层叠元素优先级的样式，z-index。 各家浏览器实现得参差不齐，但都差不多。 可Apple不一样，它有自己的设计理念。 在带有 3D 变换的元素上，它根据语义不认同z-index，而是translateZ。 我觉得这一理念，其实有点道理的，人眼在 3D 层面看待一件东西，确实是 Z 轴决定重叠优先级。 但，这CSS国际标准就可以这么任意实现嘛，在你重定自己的标准时，你想过有多少开发者会因此掉头发啊。 第三堵墙我遇到的第三堵墙便是IOS设备上的网页调试问题。 试问，在 2020 年，你如果没有一台Mac，Apple下的所有工具 都休想染指。 调试 Android 设备上的网页非常简单，只需要打开Chrome开发工具，选择远程设备即可。 可IOS设备，我只能借助第三方软件。 由于我的设备是IOS13+Win10，有很多软件都无法适配。比如，ios-webkit-debug-proxy ， RemoteDebug iOS WebKit Adapter等。 这一来二去，浪费了很长时间。最后，我想了想，只要让IOS设备能在同一网段访问本地网站就可Debug。 然后，我找到了browser-sync这一利器，满足了基本需求。 嗯，“愉快”的Debug之路便开始了。 互联网的专制者刚刚在网上刷到了贾跃亭的一封致苹果的公开信，信中所讲虽有利他之嫌，但对于苹果专制的描绘却很形象。 信中有一句话是这样描述的： 在苹果的封闭的体系中，所有的应用开发者、用户，都必须是他的顺民，都必须遵循他苛刻的规则。苹果，已成为“封闭”的代名词。 结束语额，本文有点标题党了。 但这么封闭专制的公司，不吐不快～ 转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://tomotoes.com/blog/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://tomotoes.com/blog/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Apple","slug":"Apple","permalink":"https://tomotoes.com/blog/tags/Apple/"}]},{"title":"昨日青空","date":"2019-12-19T07:32:33.000Z","path":"/yesterday/","text":"起风了。 起风了 忽然 一瞬间长大 就像 被时间的手 擦模糊的画 我们啊 各自要去哪 问题好傻 谁又能 回答 想念从 不说话 来不及的再见 多喧哗 陪我看大雨落下 潮湿的心 滴滴答答 带着温柔 又想起你啊 我好想你 在起风的夜里 我好想你 在人群的缝隙 你听见吗 这一句喜欢你 追得上你背影吗 那些大喊过的名字 没完成的约定 全都藏在心底 开出寂寞的花 你好吗 为什么长大就要走散啊 你现在在哪里 隔我多远距离 是否勇敢飞行 有没有人爱你 每当我想起你 世界突然安静 你也一样吗 青春有你出席 不是为了让你缺席 好想沿着回忆 狂奔向你 昨日的青空 随少年 挥手消失在 人海之中 你在吗 你要幸福啊 我想你啊 。 #post-content > p:nth-child(1),#post-toc,#起风了{display:none}#post-content>p,#post-content>h3{text-align:center;border-bottom:none}.post-count-custom{display:none}#post-content>h3{margin-bottom:15px;margin-top:20px;border-bottom:dashed #efefef 5px;}.post {line-height:180% !important;font-size:105%;letter-spacing:4px;border-radius:20px;text-shadow: rgb(158, 158, 158) 0px 0px 1px;color:hsl(250,13%,30%);padding:0 20px;transition:all .3s ease-in;}.post:hover{transform:translateY(-1px);transition:all 0.2s;}@media screen and (max-width:760px){.post{letter-spacing: 1px;}}","categories":[{"name":"诗词","slug":"诗词","permalink":"https://tomotoes.com/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"诗词","slug":"诗词","permalink":"https://tomotoes.com/blog/tags/%E8%AF%97%E8%AF%8D/"}]},{"title":"[开源福利]Scrcpy-GUI","date":"2019-08-24T13:59:37.000Z","path":"/scrcpy-gui/","text":"高效控制你的 Android 设备。 前言💡简介 是由流行的Android模拟器Genymotion背后的团队创建的，但它本身并不是Android模拟器，它显示和控制通过USB（或通过TCP/IP）连接的Android设备，它不需要任何root访问权限，它适用于GNU/Linux、Windows和MacOS。 Scrcpy的工作原理是在你的Android设备上运行服务器，桌面应用程序使用USB（或使用ADB隧道无线）进行通信。服务器流式传输设备屏幕的H.264视频。 客户端解码视频帧并显示它们。客户端捕获输入（键盘和鼠标）事件，将它们发送到服务器，服务器将它们注入设备。文档提供了更多详细信息。 如果你想在桌面上看到你的Android屏幕与应用程序或内容进行交互，记录你的手机屏幕或执行其他基本任务，那Scrcpy就是一个好的选择。 简而言之，Scrcpy是一种极好的方式，可以在你的计算机上轻松查看你的Android屏幕，并且可以实时与其进行交互。 引用自云网牛站 ✨亮点 亮度 （原生，仅显示设备屏幕） 表演 （30~60fps） 质量 （1920×1080 或以上） 低延迟 （70~100ms） 启动时间短 （显示第一张图像约 1 秒） 非侵入性 （设备上没有安装任何东西） 不需要 ROOT 有线无线都可连接 可以随便调整界面和码率 画面随意裁剪，自带录屏（手游直播利器） 支持多设备同时投屏 利用电脑的键盘和鼠标可以控制手机 把 APK 文件拖拽到电脑窗口即可安装应用到手机，把普通文件拖拽到窗口即可复制到手机 手机电脑共享剪贴板 自动检测 USB 连接的应用 可直接添加设备的局域网 IP，达到无线控制的效果 将自动保存连接过的 IP 地址，下次输入时，自动提醒 支持设备别名 支持中英两种语言 Tray menu 等等等… 部分引用自最美应用 正文🌞要求 Android 5.0以上 打开 USB 调试 在 开发人员选项 打开 USB 调试，USB 连接手机 安装好ADB ，并配置环境变量。 Windows Mac OS Linux 在任何路径下打开命令行，键入 ADB 有反馈。 安装好scrcpy，并配置环境变量 Windows Windows 可以使用包含所有依赖项（包含adb）的预构建存档： 下载下面scrcpy的压缩包，里面有ADB文件，然后把解压后的scrcpy文件夹添加到环境变量，再重启电脑，就可以了。 scrcpy-win32-v1.10.zip scrcpy-win64-v1.10.zip 你也可以手动构建。 Mac OS 可以使用 Homebrew 来安装： 1brew install scrcpy 如果你还没有安装ADB，可以使用下面的命令： 1brew cask install android-platform-tools 当然，你也可以手动构建。 Linux 你可能需要手动构建应用程序。别担心，这并不难。 此外，提供了 Snap) 包：scrcpy 对于 Arch Linux， 可以使用 AUR 包：scrcpy 对于 Gentoo，可以使用 Ebuild 包： scrcpy/ 🎉安装点击此处下载应用。 🎇使用连接方法必备条件 请确保 adb , scrcpy 可正常使用 请确保手机已打开 USB 调试, 并已认证电脑调试 有线连接 请确保手机已通过数据线连接到电脑 等待软件自动检测到设备 选中设备，点击打开选中的镜像 等待设备打开 无线连接 请确保手机与电脑处在同一局域网 第一次无线连接时: 请确保手机已通过数据线连接到电脑 请确保只有一个手机通过数据线连接到电脑 第一次需设置端口，以后连接手机，只需要添加手机的静态 IP 即可 输入手机的局域网IP地址（如果IP为DHCP分配，请更改为静态IP） 点击开启无线连接 等待无线连接成功 选中设备，点击打开选中的镜像 等待设备打开 🎯开发1234567891011# install dependenciesnpm install# serve with hot reload at localhost:9080npm run dev# build electron application for productionnpm run build# lint all JS/Vue component files in `src/`npm run lint 📃协议GNU GPLv3 结束语 如果你有任何问题，欢迎提交 Issues 或 PR！ 转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。","categories":[{"name":"开源","slug":"开源","permalink":"https://tomotoes.com/blog/categories/%E5%BC%80%E6%BA%90/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"开源","slug":"开源","permalink":"https://tomotoes.com/blog/tags/%E5%BC%80%E6%BA%90/"}]},{"title":"Go 开发中的十大常见陷阱[译]","date":"2019-08-17T09:26:05.000Z","path":"/the-top-10-most-common-mistakes-ive-seen-in-go-projects/","text":"Golang 中要注意的陷阱和常见错误。 前言原文: The Top 10 Most Common Mistakes I’ve Seen in Go Projects 作者: Teiva Harsanyi 翻译许可: image-20210118234116954 img 我在 Go 开发中遇到的十大常见错误。顺序无关紧要。 正文未知的枚举值让我们看一个简单的例子: 1234567type Status uint32const ( StatusOpen Status = iota StatusClosed StatusUnknown) 在这里，我们使用 iota 创建了一个枚举，其结果如下： 123StatusOpen = 0StatusClosed = 1StatusUnknown = 2 现在，让我们假设这个Status类型是 JSON 请求的一部分，将被marshalled/unmarshalled。 我们设计了以下结构： 12345type Request struct { ID int `json:\"Id\"` Timestamp int `json:\"Timestamp\"` Status Status `json:\"Status\"`} 然后，接收这样的请求： 12345{ \"Id\": 1234, \"Timestamp\": 1563362390, \"Status\": 0} 这里没有什么特别的，状态会被unmarshalled为StatusOpen。 然而，让我们以另一个未设置状态值的请求为例: 1234{ \"Id\": 1235, \"Timestamp\": 1563362390} 在这种情况下，请求结构的Status字段将初始化为它的零值(对于uint32类型:0)，因此结果将是StatusOpen而不是StatusUnknown。 那么最好的做法是将枚举的未知值设置为 0： 1234567type Status uint32const ( StatusUnknown Status = iota StatusOpen StatusClosed) 如果状态不是 JSON 请求的一部分，它将被初始化为StatusUnknown，这才符合我们的期望。 自动优化的基准测试基准测试需要考虑很多因素的,才能得到正确的测试结果。 一个常见的错误是测试代码无形间被编译器所优化。 下面是teivah/bitvector库中的一个例子: 123func clear(n uint64, i, j uint8) uint64 { return (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n} 此函数清除给定范围内的位。为了测试它，可能如下这样做: 12345func BenchmarkWrong(b *testing.B) { for i := 0; i &lt; b.N; i++ { clear(1221892080809121, 10, 63) }} 在这个基准测试中，clear不调用任何其他函数，没有副作用。所以编译器将会把clear优化成内联函数。一旦内联，将会导致不准确的测试结果。 一个解决方案是将函数结果设置为全局变量，如下所示： 123456789var result uint64func BenchmarkCorrect(b *testing.B) { var r uint64 for i := 0; i &lt; b.N; i++ { r = clear(1221892080809121, 10, 63) } result = r} 如此一来，编译器将不知道clear是否会产生副作用。 因此，不会将clear优化成内联函数。 延伸阅读High Performance Go Workshop 被转移的指针在函数调用中，按值传递的变量将创建该变量的副本，而通过指针传递只会传递该变量的内存地址。 那么，指针传递会比按值传递更快吗？请看一下这个例子。 我在本地环境上模拟了0.3KB的数据，然后分别测试了按值传递和指针传递的速度。 结果显示：按值传递比指针传递快 4 倍以上，这很违背直觉。 测试结果与 Go 中如何管理内存有关。我虽然不能像威廉·肯尼迪那样出色地解释它，但让我试着总结一下。 译者注开始 作者没有说明 Go 内存的基本存储方式，译者补充一下。 下面是来自 Go 语言圣经的介绍： 一个 goroutine 会以一个很小的栈开始其生命周期，一般只需要 2KB。 一个 goroutine 的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和 OS 线程不太一样的是，一个 goroutine 的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。 而 goroutine 的栈的最大值有 1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多 goroutine 都不需要这么大的栈。 译者自己的理解： 栈：每个 Goruntine 开始的时候都有独立的栈来存储数据。（Goruntine 分为主 Goruntine 和其他 Goruntine，差异就在于起始栈的大小） 堆: 而需要被多个 Goruntine 共享的数据，存储在堆上面。 译者注结束 众所周知，可以在堆或栈上分配变量。 栈储存当前Goroutine的正在使用的变量（译者注: 可理解为局部变量）。一旦函数返回，变量就会从栈中弹出。 堆储存共享变量（全局变量等）。 让我们看一个简单的例子，返回单一的值： 12345func getFooValue() foo { var result foo // Do something return result} 当调用函数时，result变量会在当前 Goruntine 栈创建，当函数返回时，会传递给接收者一份值的拷贝。而result变量自身会从当前 Goruntine 栈出栈。 虽然它仍然存在于内存中，但它不能再被访问。并且还有可能被其他数据变量所擦除。 现在，在看一个返回指针的例子： 12345func getFooPointer() *foo { var result foo // Do something return &amp;result} 当调用函数时，result变量会在当前 Goruntine 栈创建，当函数返回时，会传递给接收者一个指针（变量地址的副本）。如果result变量从当前 Goruntine 栈出栈，则接收者将无法再访问它。（译者注：此情况称为“内存逃逸”） 在这个场景中，Go 编译器将把result变量转义到一个可以共享变量的地方:堆。 不过，传递指针是另一种情况。例如： 1234func main() { p := &amp;foo{} f(p)} 因为我们在同一个 Goroutine 中调用f，所以p变量不需要转义。它只是被推送到堆栈，子功能可以访问它。（译者注：不需要其他 Goruntine 共享的变量就存储在栈上即可） 比如，io.Reader中的Read方法签名，接收切片参数，将内容读取到切片中，返回读取的字节数。而不是返回读取后的切片。（译者注：如果返回切片，会将切片转义到堆中。） 123type Reader interface { Read(p []byte) (n int, err error)} 为什么栈如此之快？ 主要有两个原因： 堆栈不需要垃圾收集器。就像我们说的，变量一旦创建就会被入栈，一旦函数返回就会从出栈。不需要一个复杂的进程来回收未使用的变量。 储存变量不需要考虑同步。堆属于一个 Goroutine，因此与在堆上存储变量相比，存储变量不需要同步。 总之，当创建一个函数时，我们的默认行为应该是使用值而不是指针。只有在我们想要共享变量时才应使用指针。 如果我们遇到性能问题，可以使用go build -gcflags \"-m -m\"命令，来显示编译器将变量转义到堆的具体操作。 再次重申，对于大多数日常用例来说，值传递是最合适的。 延伸阅读 Language Mechanics On Stacks And Pointers Understanding Allocations: the Stack and the Heap - GopherCon SG 2019 出乎意料的 break如果f返回 true，下面的例子中会发生什么？ 12345678for { switch f() { case true: break case false: // Do something }} 我们将调用break语句。然而，将会break出switch语句，而不是for循环。 同样的问题： 12345678for { select { case &lt;-ch: // Do something case &lt;-ctx.Done(): break } } break与select语句有关，与for循环无关。 break出for/switch 或 for/select的一种解决方案是使用带标签的 break，如下所示： 123456789loop: for { select { case &lt;-ch: // Do something case &lt;-ctx.Done(): break loop } } 缺失上下文的错误Go 在错误处理方面仍然有待提高，以至于现在错误处理是 Go2 中最令人期待的需求。 当前的标准库(在 Go 1.13 之前)只提供error的构造函数，自然而然就会缺失其他信息。 让我们看一下pkg/errors库中错误处理的思想： An error should be handled only once. Logging an error is handling an error. So an error should either be logged or propagated. （译：错误应该只处理一次。记录log 错误就是在处理错误。所以，错误应该记录或者传播） 对于当前的标准库，很难做到这一点，因为我们希望向错误中添加一些上下文信息，使其具有层次结构。 例如: 所期望的REST调用导致数据库问题的示例： 123unable to server HTTP POST request for customer 1234 |_ unable to insert customer contract abcd |_ unable to commit transaction 如果我们使用pkg/errors，可以这样做： 123456789101112131415161718192021func postHandler(customer Customer) Status { err := insert(customer.Contract) if err != nil { log.WithError(err).Errorf(\"unable to server HTTP POST request for customer %s\", customer.ID) return Status{ok: false} } return Status{ok: true}}func insert(contract Contract) error { err := dbQuery(contract) if err != nil { return errors.Wrapf(err, \"unable to insert customer contract %s\", contract.ID) } return nil}func dbQuery(contract Contract) error { // Do something then fail return errors.New(\"unable to commit transaction\")} 如果不是由外部库返回的初始error可以使用error.New创建。中间层insert对此错误添加更多上下文信息。最终通过log错误来处理错误。每个级别要么返回错误，要么处理错误。 我们可能还想检查错误原因来判读是否应该重试。假设我们有一个来自外部库的db包来处理数据库访问。 该库可能会返回一个名为db.DBError的临时错误。要确定是否需要重试，我们必须检查错误原因： 使用pkg/errors中提供的errors.Cause可以判断错误原因。 123456789101112131415161718192021func postHandler(customer Customer) Status { err := insert(customer.Contract) if err != nil { switch errors.Cause(err).(type) { default: log.WithError(err).Errorf(\"unable to server HTTP POST request for customer %s\", customer.ID) return Status{ok: false} case *db.DBError: return retry(customer) } } return Status{ok: true}}func insert(contract Contract) error { err := db.dbQuery(contract) if err != nil { return errors.Wrapf(err, \"unable to insert customer contract %s\", contract.ID) } return nil} 我见过的一个常见错误是部分使用pkg/errors。 例如，通过这种方式检查错误： 1234567switch err.(type) {default: log.WithError(err).Errorf(\"unable to server HTTP POST request for customer %s\", customer.ID) return Status{ok: false}case *db.DBError: return retry(customer)} 在此示例中，如果db.DBError被wrapped，它将永远不会执行retry。 延伸阅读Don’t just check errors, handle them gracefully 正在扩容的切片有时，我们知道切片的最终长度。假设我们想把Foo切片转换成Bar切片，这意味着这两个切片的长度是一样的。 我经常看到切片以下面的方式初始化： 12var bars []Barbars := make([]Bar, 0) 切片不是一个神奇的数据结构，如果没有更多可用空间，它会进行双倍扩容。在这种情况下，会自动创建一个切片(容量更大)，并复制其中的元素。 如果想容纳上千个元素，想象一下，我们需要扩容多少次。虽然插入的时间复杂度是O(1)，但它仍会对性能有所影响。 因此，如果我们知道最终长度，我们可以: 用预定义的长度初始化它 1234567func convert(foos []Foo) []Bar { bars := make([]Bar, len(foos)) for i, foo := range foos { bars[i] = fooToBar(foo) } return bars} 或者使用长度 0 和预定义容量初始化它： 1234567func convert(foos []Foo) []Bar { bars := make([]Bar, 0, len(foos)) for _, foo := range foos { bars = append(bars, fooToBar(foo)) } return bars} 无规范的 Contextcontext.Context 经常被误用。 根据官方文档: A Context carries a deadline, a cancelation signal, and other values across API boundaries. 这种描述非常笼统，以至于让一些人对使用它感到困惑。 让我们试着详细描述一下。Context可以包含: A deadline（最后期限）。它意味着到期之后（250ms 之后或者一个指定的日期），我们必须停止正在进行的操作（I/O请求，等待的channel输入，等等）。 A cancelation signal（取消信号）。一旦我们收到信号，我们必须停止正在进行的活动。例如，假设我们收到两个请求：一个用来插入一些数据，另一个用来取消第一个请求。这可以通过在第一个调用中使用cancelable上下文来实现，一旦我们获得第二个请求，这个上下文就会被取消。 A list of key/value （键/值列表）均基于interface{}类型。 值得一提的是，Context 是可以组合的。例如，我们可以继承一个带有截止日期和键/值列表的Context。此外，多个goroutines可以共享相同的Context，取消一个Context可能会停止多个活动。 回到我们的主题，举一个我经历的例子。 一个基于urfave/cli （如果您不知道，这是一个很好的库，可以在 Go 中创建命令行应用程序）创建的 Go 应用。一旦开始，程序就会继承父级的Context。这意味着当应用程序停止时，将使用此Context发送取消信号。 我经历的是，这个Context是在调用gRPC时直接传递的，这不是我想做的。相反，我想当应用程序停止时或无操作 100 毫秒后，发送取消请求。 为此，可以简单地创建一个组合的Context。如果parent是父级的Context的名称（由 urfave/cli 创建），那么组合操作如下： 12ctx, cancel := context.WithTimeout(parent, 100 * time.Millisecond)response, err := grpcClient.Send(ctx, request) Context并不复杂，在我看来，可谓是 Go 的最佳特性之一。 延伸阅读 Understanding the context package in golang gRPC and Deadlines 被遗忘的-race 参数我经常看到的一个错误是在没有-race参数的情况下测试 Go 应用程序。 正如本报告所述，虽然 Go“旨在使并发编程更容易，更不容易出错”，但我们仍然遇到很多并发问题。 显然，Go 竞争检测器无法解决每一个并发问题。但是，它仍有很大价值，我们应该在测试应用程序时始终启用它。 延伸阅读Does the Go race detector catch all data race bugs? 更完美的封装另一个常见错误是将文件名传递给函数。 假设我们实现一个函数来计算文件中的空行数。最初的实现是这样的： 12345678910111213141516func count(filename string) (int, error) { file, err := os.Open(filename) if err != nil { return 0, errors.Wrapf(err, \"unable to open %s\", filename) } defer file.Close() scanner := bufio.NewScanner(file) count := 0 for scanner.Scan() { if scanner.Text() == \"\" { count++ } } return count, nil} filename 作为给定的参数，然后我们打开该文件，再实现读空白行的逻辑，嗯，没有问题。 假设我们希望在此函数之上实现单元测试，并使用普通文件，空文件，具有不同编码类型的文件等进行测试。代码很容易变得非常难以维护。 此外，如果我们想对于HTTP Body实现相同的逻辑，将不得不为此创建另一个函数。 Go 设计了两个很棒的接口：io.Reader 和 io.Writer (译者注：常见 IO 命令行，文件，网络等) 所以可以传递一个抽象数据源的io.Reader，而不是传递文件名。 仔细想一想统计的只是文件吗？一个 HTTP 正文？字节缓冲区？ 答案并不重要，重要的是无论Reader读取的是什么类型的数据，我们都会使用相同的Read方法。 在我们的例子中，甚至可以缓冲输入以逐行读取它（使用bufio.Reader及其ReadLine方法）： 1234567891011121314151617func count(reader *bufio.Reader) (int, error) { count := 0 for { line, _, err := reader.ReadLine() if err != nil { switch err { default: return 0, errors.Wrapf(err, \"unable to read\") case io.EOF: return count, nil } } if len(line) == 0 { count++ } }} 打开文件的逻辑现在交给调用count方： 123456file, err := os.Open(filename)if err != nil { return errors.Wrapf(err, \"unable to open %s\", filename)}defer file.Close()count, err := count(bufio.NewReader(file)) 无论数据源如何，都可以调用count。并且，还将促进单元测试，因为可以从字符串创建一个bufio.Reader，这大大提高了效率。 1count, err := count(bufio.NewReader(strings.NewReader(\"input\"))) Goruntines 与循环变量我见过的最后一个常见错误是使用 Goroutines 和循环变量。 以下示例将会输出什么？ 123456ints := []int{1, 2, 3}for _, i := range ints { go func() { fmt.Printf(\"%v\\n\", i) }()} 乱序输出 1 2 3 ？答错了。 在这个例子中，每个 Goroutine 共享相同的变量实例，因此最有可能输出3 3 3。 有两种解决方案可以解决这个问题。 第一种是将i变量的值传递给闭包（内部函数）： 123456ints := []int{1, 2, 3}for _, i := range ints { go func(i int) { fmt.Printf(\"%v\\n\", i) }(i)} 第二种是在for循环范围内创建另一个变量： 1234567ints := []int{1, 2, 3}for _, i := range ints { i := i go func() { fmt.Printf(\"%v\\n\", i) }()} i := i可能看起来有点奇怪，但它完全有效。 因为处于循环中意味着处于另一个作用域内，所以i := i相当于创建了另一个名为i的变量实例。 当然，为了便于阅读，最好使用不同的变量名称。 延伸阅读Using goroutines on loop iterator variables 结束语你还想提到其他常见的错误吗？请随意分享，继续讨论；) 转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。","categories":[{"name":"后端","slug":"后端","permalink":"https://tomotoes.com/blog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://tomotoes.com/blog/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"Go","permalink":"https://tomotoes.com/blog/tags/Go/"},{"name":"译文","slug":"译文","permalink":"https://tomotoes.com/blog/tags/%E8%AF%91%E6%96%87/"}]},{"title":"如何成为 IDEA 键盘流","date":"2019-05-28T02:25:44.000Z","path":"/jetbrains-ide-efficient-shortcuts/","text":"好了，你完全可以丢掉鼠标了。 前言 常言道：“工欲善其事必先利其器”。 如何高效编程，成为 JetBrainsIDE 键盘流呢？ 当然是熟悉快捷键再加上各种插件啦~ IDEA JetBrainsIDE 有默认的一套快捷键方案，不过在经过长时间的使用后，发现总有些一些快捷键令我难以接受。 遂花了一天的时间，将快捷键全部调整了一遍，并深度结合了IdeaVim插件，总结如下： 本篇文章适用于任何 JetBrains 公司出品的 IDE ，包括 PhpStorm ，WebStorm ，PyCharm ，RubyMine ，CLion 等。 IDEA 正文快捷键多光标 添加或移除光标 Ctrl + 左键 拖动鼠标选中多行区域 Shift + 左键拖动 在上方/下方插入光标 Ctrl + Alt + 上下键 编辑 删除行 Ctrl + D 重复行或选中区域 Ctrl + Shift + C 连接行 Ctrl + J 扩展选择 Ctrl + Shift + [/] 切换大小写 Ctrl + Shift + U 移动行 Alt + 上/下 移动 上移或下移 Ctrl + 上下键 上移或者下移并根据相对位置滚动 Ctrl + Shift + 上下键 开始新行 Ctrl/Shift + Enter 查找 Ctrl + F 全局查找 Ctrl + Shift + F 替换 Ctrl + H 全局替换 Ctrl + Shift + H 选择所有匹配项 Ctrl + Shift + Y 将下一个匹配项添加到选择 Ctrl + Y 取消选择匹配项 Ctrl + Alt + Y 跳转到下一个匹配项 Ctrl + ‘ 跳转到上一个匹配项 Ctrl + Shift + ‘ 例举最近位置 Alt + X 跳转到上/下一次编辑代码的位置 Ctrl + Alt + 左右 切换书签 Ctrl + Shift + Q 显示书签 Alt + Shift + Q 进入查找的跳转模式 Ctrl + ; 进入枚举的跳转模式 Ctrl + Shift + ; 代码 快捷文档 Ctrl + Q 参数信息 Ctrl + Shift + Space 显示实现方法的代码 Ctrl + G 跳转到实现方法的代码 Ctrl + Shift + D 查看结构体实现的所有接口 Ctrl + I 查看函数的所有调用者 Ctrl + M 为当前代码生成包裹它的复合语句(if/for) Ctrl + ] 从当前复合语句中,剥离代码 Ctrl + [ 为变量寻找一个接口去实现,并自动生成该接口中定义的所有方法的待实现模板 Ctrl + Shift + I 为变量寻找一个接口去实现,并自动生成该接口中定义的所有方法的待实现模板 Ctrl + Shift + X 为当前结构体生成构造函数 Ctrl + Shift + X 为当前结构体的字段生成存取器 Ctrl + Shift + X 为当前方法/文件/包生产测试文件 Ctrl + Shift + X 为当前文件生成版权 Ctrl + Shift + X 基本补全 Ctrl + Shift + A 检查代码 Ctrl + Shift + J 插入代码模板 Alt + Enter 行注释 Ctrl + R 块注释 Ctrl + / 格式化代码 Ctrl + T 重构(重命名,更改签名,移动,赋值,提取变量) Ctrl + Shift + R 从浏览器打开文档 F1 展示智能提示 Ctrl + Shift + Enter Debug 运行 F5 调试 Ctrl + F5 停止 F4 在调试中运行到光标处 Shift + F5 在调试中强制运行到光标处 Ctrl + Shift + F5 切换断点 Alt + D 调试窗口 F6 项目 新建文件 Ctrl + N 新建目录 Ctrl + Shift + N 打开项目 Ctrl + O 保存全部 Ctrl + S 最近文件 Ctrl + E 在资源管理器中打开项目 Alt + R 标签 关闭标签 Ctrl + W 关闭所有标签 Ctrl + Shift + W 重新打开关闭的标签 Ctrl + Shift + T 移动标签 Alt + 左右 / 拆分窗口 Ctrl + \\ 更改拆分方向 Alt + \\ 取消拆分 Ctrl + Shift + \\ 转到下一个/上一个拆分窗口 Ctrl + Alt + [/] 折叠 折叠当前代码块 Ctrl + - 展开当前代码块 Ctrl + = 递归折叠代码块 Ctrl + Alt + - 递归展开代码块 Ctrl + Alt + = 折叠所有代码块 Ctrl + Shift + - 展开所有代码块 Ctrl + Shift + = IDE 设置 Ctrl + Shift + S 重启 Ctrl + Shift + M 全屏 F11 关闭其他窗口 Ctrl + Shift + B 关闭活动窗口 Ctrl + P 查找帮助 Ctrl + Shift + A 消息日志 Ctrl + Shift + L 项目管理 Ctrl + Shift + E 文件大纲 Ctrl + Shift + P 终端 Alt + Q 重命名 F2 Search Everywhere Shift + Shift 键入 Tab 切换子面板 Favorites Ctrl + K Hierachy Ctrl + Shift + O TODO Ctrl + L 版本控制窗口 Ctrl + Shift + G 调试窗口 F6 调整字体大小 Ctrl + 滚轮 重置字体大小 Ctrl + 0 IdeaVim 切换开关 Alt + J 映射为 ESC 的键 jj 修改原始 Vim 的映射 行首，行尾 H，L 重做 U Actions 12345678910键 动作gd GotoDeclarationga GotoActiongt GotoClassgs GotoSymbolgf GotoFileSpace + v + s 重载配置文件Space + ; AceJump 模式Alt + h/l 上/下一个标签Alt + j/k 前进/后退 安装配置快捷键 克隆我下面的dotfiles仓库 找到 JetBrainsIDE.zip 在 你使用的 JetBrains 家族的 IDE 中导入设置 选择快捷键进行导入 IdeaVim如果你还不熟悉 Vim，可以先看我的这两篇文章： Vim 修炼秘籍之命令篇 Vim 修炼秘籍之语法篇 安装步骤如下： 安装插件，键入关键字ideaVim搜索 在 ~ 目录下，创建.ideavimrc 复制以下内容到.ideavimrc文件 个人的IdeaVim 配置文件： 点击显/隐源文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115let mapleader=' 'set nowrapset sidescroll=40set nobackset hlsearchset incsearchset ignorecaseset smartcaseset showmodeset nocompatibleset backspace=indent,eol,startset rulerset relativenumberset numberset scrolloff=3set history=100000set clipboard+=unnamedset surroundset so=5set autoreadset winaltkeys=noset showmatchset matchtime=2set cmdheight=2set multiple-cursorsinoremap jj &lt;Esc&gt;vnoremap v &lt;Esc&gt;nnoremap L $vnoremap L $nnoremap H ^vnoremap H ^nnoremap Y v$yvnoremap Y $ynnoremap &lt;s-j&gt; :action EditorJoinLines&lt;CR&gt;nnoremap &lt;c-up&gt; :action EditorScrollUp&lt;CR&gt;nnoremap &lt;c-down&gt; :action EditorScrollDown&lt;CR&gt;nnoremap &lt;s-left&gt; :action EditorLeftWithSelection&lt;CR&gt;nnoremap &lt;s-right&gt; :action EditorRightWithSelection&lt;CR&gt;nnoremap &lt;s-up&gt; :action EditorUpWithSelection&lt;CR&gt;nnoremap &lt;s-down&gt; :action EditorDownWithSelection&lt;CR&gt;inoremap &lt;s-left&gt; &lt;C-O&gt;:action EditorLeftWithSelection&lt;CR&gt;inoremap &lt;s-right&gt; &lt;C-O&gt;:action EditorRightWithSelection&lt;CR&gt;inoremap &lt;s-up&gt; &lt;C-O&gt;:action EditorUpWithSelection&lt;CR&gt;inoremap &lt;s-down&gt; &lt;C-O&gt;:action EditorDownWithSelection&lt;CR&gt;\" enter newlinesnnoremap &lt;CR&gt; :action EditorEnter&lt;CR&gt;inoremap &lt;CR&gt; &lt;C-o&gt;:action EditorEnter&lt;CR&gt;nnoremap / :action Find&lt;cr&gt;nnoremap n :action FindNext&lt;CR&gt;nnoremap N :action FindPrevious&lt;CR&gt;nnoremap &lt;Leader&gt;/ /nnoremap U :action $Redo&lt;CR&gt;\" Reload .ideavimrcnnoremap &lt;Leader&gt;vs :source ~/.ideavimrc&lt;CR&gt;\" have x (removes single character) not go into the default registrynnoremap x \"_x\" Make X an operator that removes without placing text in the default registrynmap X \"_dnmap XX \"_ddvmap X \"_dvmap x \"_d\" Center screen when jumping to next matchnnoremap n nzznnoremap N Nzzvnoremap n nzzvnoremap N Nzznoremap # #zznoremap * *zznoremap w wzznoremap W Wzznoremap e ezznoremap E Ezznoremap b bzznoremap B Bzznoremap H Hzznoremap L Lzznoremap 0 0zznoremap $ $zznoremap ^ ^zznoremap j jzznoremap k kzznoremap G Gzznoremap u uzznoremap ( (zznoremap ) )zznoremap { {zznoremap } }zznoremap [{ [{zznoremap ]} ]}zznoremap gd gdzznnoremap &lt;leader&gt;; :action AceAction &lt;CR&gt;nnoremap &lt;a-h&gt; gTnnoremap &lt;a-l&gt; gtnnoremap &lt;a-j&gt; :action Back &lt;CR&gt;nnoremap &lt;a-k&gt; :action Resume &lt;CR&gt; 结束语好了，你现在完全可以丢掉鼠标了。 转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。","categories":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"IDEA","slug":"IDEA","permalink":"https://tomotoes.com/blog/tags/IDEA/"},{"name":"快捷键","slug":"快捷键","permalink":"https://tomotoes.com/blog/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}]},{"title":"服务器初始化","date":"2019-05-05T07:37:04.000Z","path":"/server-initialization-step/","text":"记一下服务器的初始配置。 前言前些日子，入手了一台服务器，特此记录一下它的初始配置。 正文注：本人主机为 CentOS 7 x64 系统，以下内容均基于此环境。 安全设置请查考 肉鸡是怎样炼成的 字符集修改123456cd /etc/sysconfig/sudo vi i18nLANG=\"zh_CN.utf8\"source /etc/sysconfig/i18n 设置 DNS123vi /etc/resolv.confnameserver 114.114.114.114nameserver 8.8.8.8 配置 Yum 源123456cd /etc/yum.repos.d/sudo mv CentOS-Base.repo CentOS-Base.repo_baksudo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum clean allyum makecache 设置时区1234yum install ntp -ytimedatectl set-timezone Asia/Shanghaitimedatectl set-ntp yes #同步timedatectl # 查看时区 软件安装常用软件12345yum install epel-release -yyum -y updateyum clean allyum makecacheyum -y install wget bind-utils net-tools lrzsz gcc gcc-c++ make cmake libxml2-devel openssl-devel curl curl-devel unzip sudo ntp libaio-devel wget ncurses-devel autoconf automake zlib-devel python-devel Vim1234yum -y install vimcurl -sLf https://spacevim.org/cn/install.sh | bash -s -- -hvi ~/.SpaceVim.d/ Git12345678yum -y install gitgit config --global user.name SimonMagit config --global user.email simon@tomotoes.comgit config --global http.sslverify falsegit config --global https.sslverify false# 远程仓库密钥生成ssh-keygen -t rsa -C \"simon@tomotoes.com\" Zsh12345678910111213141516171819202122232425262728293031323334353637383940414243# 安装 zsh 包yum -y install zsh# 切换默认 shell 为 zshchsh -s /bin/zsh# 重启服务器reboot# 安装 on my zshsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" vi ~/.zshrcZSH_THEME=\"agnoster\"# autojumpyum install autojump -yyum install autojump-zsh# zsh-autosuggestionsgit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions# zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting# 配置.zshrc 文件plugins=( git autojump zsh-autosuggestions zsh-syntax-highlighting z extract)source ~/.zshrc更新upgrade_oh_my_zsh卸载uninstall_oh_my_zsh 连按两次 Tab 会列出所有的补全列表并直接开始选择，补全项可以使用 ctrl+n/p/f/b 上下左右切换 命令选项补全。在 zsh 中只需要键入 tar - 就会列出所有的选项和帮助说明 命令参数补全。键入 kill 就会列出所有的进程名和对应的进程号 更智能的历史命令。在用或者方向上键查找历史命令时，zsh 支持限制查找。比如，输入 ls,然后再按方向上键，则只会查找用过的 ls 命令。而此时使用则会仍然按之前的方式查找，忽略 ls 多个终端会话共享历史记录 智能跳转，安装了 autojump 之后，zsh 会自动记录你访问过的目录，通过 j 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过 hadoop-1.0.0 目录，输入 j hado 即可正确跳转。j –stat 可以看你的历史路径库。 目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。 在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。在你知道路径的情况下，比如 /usr/local/bin 你可以输入 cd /u/l/b 然后按进行补全快速输入 通配符搜索：ls -l /*.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find。使用 / 来递归搜索 扩展环境变量，输入环境变量然后按 就可以转换成表达的值 在 .zshrc 中添加 setopt HIST_IGNORE_DUPS 可以消除重复记录，也可以利用 sort -t “;” -k 2 -u ~/.zsh_history | sort -o ~/.zsh_history 手动清除 至此，你现在的 zsh 应该具备如下几个特性： 各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下tab键，补全项可以使用ctrl+n/p/f/b 上下左右切换。比如你想杀掉 java 的进程，只需要输入kill java + tab 键，如果只有一个 java 进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个 tab 键，zsh 会列出所有访问过的主机和用户名进行补全； 即使你没有安装autojump，只要输入d，就会列出你在这个回话中访问的目录，输入前面的序号，就可以直接跳转； 可以忽略 cd 命令, 输入..或者...和当前目录名都可以跳转； 当然，除了上面几点，zsh 还有很多丰富的插件可以使用，这就需要继续的探索了… Nodejs12345678910111213curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bashsource ~/.bashrc# 安装 node 的最新稳定版nvm install stable# 查看安装版本nvm list# 配置npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/distnpm config set puppeteer_download_host https://npm.taobao.org/mirrors Nginx123456789sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpmsudo yum install -y nginx# 启动 Nginxsudo systemctl start nginx.service# 将 Nginx 加入到开机启动sudo systemctl enable nginx.service 命令别名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586vi ~/.zshrcalias shadow='/etc/init.d/shadowsocks'alias vi='vim'alias ls='ls --color=auto'alias ll=\"ls --color -al\"alias grep='grep --color=auto'# 查看当前时间alias now='date \"+%Y-%m-%d %H:%M:%S\"'alias reboot='sudo /sbin/reboot'alias poweroff='sudo /sbin/poweroff' alias halt='sudo /sbin/halt'alias shutdown='sudo /sbin/shutdown'# 自动创建父目录alias mkdir='mkdir -pv'# 解压任何文件extract() { if [ -f $1 ] ; then case $1 in *.tar.bz2) tar xjf $1 ;; *.tar.gz) tar xzf $1 ;; *.bz2) bunzip2 $1 ;; *.rar) unrar e $1 ;; *.gz) gunzip $1 ;; *.tar) tar xf $1 ;; *.tbz2) tar xjf $1 ;; *.tgz) tar xzf $1 ;; *.zip) unzip $1 ;; *.Z) uncompress $1 ;; *.7z) 7z x $1 ;; *) echo \"'$1' cannot be extracted via extract()\" ;; esac else echo \"'$1' is not a valid file\" fi }# 查看文件/目录大小alias size='f(){ du -sh $1* | sort -hr; }; f'# 开放端口alias portopen='f(){ /sbin/iptables -I INPUT -p tcp --dport $1 -j ACCEPT; }; f'# 关闭端口alias portclose='f(){ /sbin/iptables -I INPUT -p tcp --dport $1 -j DROP; }; f'# 解压alias untar='tar xvf 'alias -s html='vim' # 在命令行直接输入后缀为 html 的文件名，会在 Vim 中打开alias -s rb='vim' # 在命令行直接输入 ruby 文件，会在 Vim 中打开alias -s py='vim' # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似alias -s js='vim'alias -s md='vim'alias -s mjs='vim'alias -s css='vim'alias -s c='vim'alias -s java='vim'alias -s txt='vim'alias -s gz='tar -xzvf' # 在命令行直接输入后缀为 gz 的文件名，会自动解压打开alias -s tgz='tar -xzvf'alias -s zip='unzip'alias -s bz2='tar -xjvf'alias -s json='vim'alias -s go='vim'alias cat=ccatalias man=tldreval \"$(thefuck --alias)\"# Load zsh-syntax-highlighting.source ~/.oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh## Load zsh-autosuggestions.source ~/.oh-my-zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh## Enable autosuggestions automatically.ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=\"fg=10\"# 保存source ~/.zshrc 123456789101112# 列出 bash 别名alias# 创建一个 bash shell 别名alias name=valuealias c='clear'# 删除别名unalias aliasname# 如果想要使别名永久生效， 请编辑vi ~/.zshrc 安装这两天，我完成了 CentosInit 项目，一个高度自定义的 Centos 初始化脚本。 欢迎 Star , PR ! 如果你想快速配置以上初始化措施，请执行以下命令： 通过 curl 1sh -c \"$(curl -fsSL https://tomotoes.com/Centos-init/install.sh)\" 通过 wget 1sh -c \"$(wget https://tomotoes.com/Centos-init/install.sh -O -)\" 基本介绍脚本功能一共分为四大类: 初始化配置（update） 123456789updateLanguageupdateTimeupdateLanguageupdateTimeupdateDNSupdateYumSourceupdateHostnameupdateUlimitupdateCoreConfig 安装常用软件（install） 123456789101112installCommonSoftinstallGitinstallViminstallZshinstallNodeinstallNpmPackagesinstallPythoninstallPipPackagesinstallDockerinstallNginxinstallCcatinstallShadowSocks 配置安装后的软件（config） 1234567configVimconfigZshconfigGitconfigNodeconfigDockerconfigNginxconfigShadowSocks 必要的安全配置（secure） 基础项 12345deleteOrLockUnnecessaryUsersAndGroupssetPrivilegescloseCtrlAltDelcloseIpv6closeSELinux 高阶项 1234updateSSHPortuseKeyLoginuseIptablepreventCrackingPassword 用户相关项 1234getUserInfoaddUserjoinWheelGroupbanRootLogin 单独功能安装如果你想安装某一种功能( Update | Install | Config | Secure ) 请参考以下案列: 12345# 在安装命令前设置 ONLY_UPDATE=Y 即可只安装 update 服务ONLY_UPDATE=Y sh -c \"$(curl -fsSL https://tomotoes.com/Centos-init/install.sh)\"# Install and ConfigONLY_INSTALL=Y ONLY_CONFIG=Y sh -c \"$(curl -fsSL https://tomotoes.com/Centos-init/install.sh)\" 交互模式你也设置设置交互模式，在交互模式下，可高达自定义化你想使用的功能。 每执行完一项功能，都会询问你下一步。 使用功能的方法如下: 12# 在安装命令前设置 INTERACTIVE=YINTERACTIVE=Y sh -c \"$(curl -fsSL https://tomotoes.com/Centos-init/install.sh)\" 结束语转载本站文章请注明作者和出处 tomotoes.com，请勿用于任何商业用途。","categories":[{"name":"开源","slug":"开源","permalink":"https://tomotoes.com/blog/categories/%E5%BC%80%E6%BA%90/"}],"tags":[{"name":"开源","slug":"开源","permalink":"https://tomotoes.com/blog/tags/%E5%BC%80%E6%BA%90/"},{"name":"Linux","slug":"Linux","permalink":"https://tomotoes.com/blog/tags/Linux/"}]},{"title":"肉鸡是怎样炼成的","date":"2019-04-30T11:11:44.000Z","path":"/server-security-manual/","text":"你的服务器正在被攻击！ 前言安全是一个服务器最基本的必备条件，在创建了服务器之后，你首先要做的事情就是将服务器加固。 由于服务器就相当于一台拥有独立 IP 的、直接暴露于互联网之上的电脑，这在为你带来便利的同时也直接让你的服务器与危险画上了等号，密码穷举、DDOS 攻击、各种各样你想到的、想不到的攻击方法都在等着你。 说不定你的服务器正在被攻击！ 正文注：本人主机为 CentOS 7 x64 系统，以下内容均基于此环境。 查看攻击情况 查看登录失败的日志 1sudo lastb 统计尝试暴力破解机器密码的 IP 1sudo grep \"Failed password for invalid\" /var/log/secure | awk '{print $13}' | sort | uniq -c | sort -nr | more 统计有哪些用户名尝试登录 1sudo grep \"Failed password for invalid\" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 嗯哼，结果可怕吗? 安全措施禁止 root永远不要以 root 登录服务器。 你可以新建一个用户来管理，而非直接使用 root 用户，防止密码被破解。 增加用户 12useradd -m username# -m 可以为用户创建相应的帐号和用户目录/home/username 设置新用户密码 1passwd username 将新用户加入到 Wheel 组 1usermod -G wheel username 限制su命令 1234567vi /etc/pam.d/su# 去除下面命令的注释#auth required pam_wheel.so use_uid# 只允许管理员组的用户执行 sh 命令echo \"SU_WHEEL_ONLY yes\"&gt;&gt;/etc/login.defs 除去验证密码 123 vi /etc/sudoers # 在 root 下面增加 以下内容：username ALL=(ALL) NOPASSWD: ALL 禁止 root 登陆 12345vi /etc/ssh/sshd_configPermitRootLogin no #禁止 root 登录PermitEmptyPasswords no #禁止空密码登录AllowUsers username #设置刚才创建的用户可以登录 重启服务器 1reboot 禁用不必要的账号12345678910passwd -l dbuspasswd -l nobodypasswd -l ftppasswd -l mailpasswd -l shutdownpasswd -l haltpasswd -l operatorpasswd -l syncpasswd -l admpasswd -l lp 禁止非授权用户获得权限123456sudo chattr +i /etc/passwdsudo chattr +i /etc/shadowsudo chattr +i /etc/groupsudo chattr +i /etc/gshadowsudo chmod -R 700 /etc/rc.d/init.d/* 这样操作之后也无法创建账号和修改密码，后面可以使用chattr -i命令恢复之后再进行操作。 修改端口ssh 登陆默认的端口是22，那些扫描穷举密码的，也一定从22开始。 编辑配置文件 1sudo vi /etc/ssh/sshd_config 将其中的Port 22改为其他端口 port的取值范围是 0 – 65535(即 2 的 16 次方) 0 到 1024 是众所周知的端口（知名端口，常用于系统服务等，例如 http 服务的端口号是 80） 配置防火墙 1234#CentOS 6 中防火墙开启对应端口iptables -I INPUT -p tcp --dport 设置的端口号 -j ACCEPT #CentOS 7 中防火墙开启对应端口sudo firewall-cmd --zone=public --add-port=设置的端口号/tcp --permanent 重启 sshd 1service sshd restart 限制端口转发 编辑配置文件 1sudo vi /etc/ssh/sshd_config 修改以下内容 1234ChrootDirectory /home/%uX11Forwarding noAllowTcpForwarding noUseDNS no 重启服务器 1service sshd restart ssh 密钥登录 如果一定要使用密码登录，请查考正文最后 fail2ban 与 DenyHosts 的介绍。 不要相信自己的密码，在暴力枚举面前，只是时间文件。 统计学告诉我们，请配置 RSA 有两种不同的密钥分发方式，但结果都是一样的。 在客户端生成公钥与私钥，上传公钥到服务器 在服务器生成公钥和私钥，复制私钥到客户端 我使用第二种方式进行演示： 服务器生成密钥 1sudo ssh-keygen -b 2048 -t rsa 这样一来，在根目录就生成了一个.ssh的隐藏目录，内含两个密钥文件。 xxx 为私钥，需复制到客户端，xxx.pub 为公钥。 服务器配置公钥 12345cd ~/.sshsudo cat xxx.pub &gt;&gt; authorized_keys # 默认允许的 key 存储的文件sudo chmod 600 authorized_keyssudo chmod 700 ~/.ssh 配置 ssh 文件 123456sudo vi /etc/ssh/sshd_config#编辑以下内容RSAAuthentication yes #RSA 认证PubkeyAuthentication yes #开启公钥验证AuthorizedKeysFile .ssh/authorized_keys #验证文件路径 复制私钥到本地，并且设置相应 ssh 工具的连接配置。 重启服务器 1service sshd restart 禁止密码登录 使用密钥登录成功之后，再设置此项。 123456sudo vi /etc/ssh/sshd_config#编辑以下内容PasswordAuthentication no #禁止密码认证PermitEmptyPasswords no #禁止空密码UsePAM no#禁用 PAM iptablesiptables 是Linux上最强大的防火墙软件。 安装 123456yum install iptables -yyum install iptables-services -y #CentOS7 需安装此 iptables 的 service 软件包## Debian/Ubuntu 执行：apt-get install iptables -yapt-get install iptables-persistent -y #持久化 iptables 规则服务# CentOS 7 上默认安装了 firewalld 建议关闭并禁用： 12systemctl stop firewalldsystemctl mask firewalld 清除已有 iptables 规则 123iptables -Fiptables -Xiptables -Z 开发指定端口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 允许本地回环接口(即运行本机访问本机)iptables -A INPUT -i lo -j ACCEPT# 允许已建立的或相关连的通行iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT#允许所有本机向外的访问iptables -A OUTPUT -j ACCEPT# 允许访问 22222(SSH)端口，以下几条相同，分别是 22222,80,443 端口的访问iptables -A INPUT -p tcp --dport 22222 -j ACCEPTiptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A INPUT -p tcp --dport 443 -j ACCEPT#允许 FTP 服务的 21 和 20 端口iptables -A INPUT -p tcp --dport 21 -j ACCEPTiptables -A INPUT -p tcp --dport 20 -j ACCEPT#如果有其他端口的话，规则也类似，稍微修改上述语句就行#允许 pingiptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT#禁止其他未允许的规则访问（注意：如果 22 端口未加入允许规则，SSH 链接会直接断开。）iptables -A INPUT -j REJECT iptables -A FORWARD -j REJECT#屏蔽单个 IP 的命令是iptables -I INPUT -s 123.45.6.7 -j DROP#封整个段即从 123.0.0.1 到 123.255.255.254 的命令iptables -I INPUT -s 123.0.0.0/8 -j DROP#封 IP 段即从 123.45.0.1 到 123.45.255.254 的命令iptables -I INPUT -s 124.45.0.0/16 -j DROP#封 IP 段即从 123.45.6.1 到 123.45.6.254 的命令是iptables -I INPUT -s 123.45.6.0/24 -j DROP#屏蔽某 IP 访问指定端口，以 22 端口为例命令是iptables -I INPUT -s 123.45.6.7 -p tcp --dport 22 -j DROP#允许某 IP 访问指定端口，以 22 端口为例命令是iptables -I INPUT -p tcp --dport 22 -j DROPiptables -I INPUT -s 123.45.6.7 -p tcp --dport 22 -j ACCEPT#ACCEPT:允许通过.LOG:记录日志信息,然后传给下一条规则继续匹配.REJECT:拒绝通过,必要时会给出提示DROP:直接丢弃,不给出任何回应.PREROUTING:在进行路由选择前处理数据包INPUT:处理入站的数据包OUTPUT:处理出站的数据包FORWARD:处理转发的数据包POSTROUTING:在进行路由选择后处理数据包 保存防火墙规则 1service iptables save 设置防火墙开机启动 1234chkconfig --level 345 iptables on# CentOS7 可执行：systemctl enable iptables fail2ban如已经设置 禁止密码登录，可忽悠。 通过使用 iptables 防火墙，将尝试爆破 ssh 密码的 IP 封停，默认 10 分钟。 安装 1yum install -y fail2ban 配置 1234567891011cp -pf /etc/fail2ban/jail.conf /etc/fail2ban/jail.localvim /etc/fail2ban/jail.local[sshd]enabled = trueport = 22222logpath = %(sshd_log)sbackend = %(sshd_backend)sfilter = sshdaction = iptables[name=SSH, port=22222, protocol=tcp] sendmail-whois[name=SSH, dest=root, sender=fail2ban@example.com]logpath = /var/log/securemaxretry = 3 DenyHosts如已经设置 禁止密码登录，可忽悠。 分析sshd的日志文件，当发现重复的攻击时就会记录IP到/etc/hosts.deny文件，从而达到自动屏蔽IP的功能。 和 fail2ban 一样，都是防止暴力破解密码，两者任选其一即可。 安装 1yum install denyhosts 配置 123456789101112131415161718192021222324252627vi /etc/denyhosts.conf# 配置相关说明SECURE_LOG = /var/log/secure #ssh 日志文件,系统不同,文件不相同HOSTS_DENY = /etc/hosts.deny #控制用户登陆的文件PURGE_DENY = #过多久后清除已经禁止的，空表示永远不解禁BLOCK_SERVICE = sshd #禁止的服务名，如还要添加其他服务，只需添加逗号跟上相应的服务即可DENY_THRESHOLD_INVALID = 5 #允许无效用户失败的次数DENY_THRESHOLD_VALID = 10 #允许普通用户登陆失败的次数DENY_THRESHOLD_ROOT = 1 #允许 root 登陆失败的次数DENY_THRESHOLD_RESTRICTED = 1WORK_DIR = /var/lib/denyhosts #运行目录SUSPICIOUS_LOGIN_REPORT_ALLOWED_HOSTS=YESHOSTNAME_LOOKUP=YES #是否进行域名反解析LOCK_FILE = /var/run/denyhosts.pid #程序的进程 IDADMIN_EMAIL = root@localhost #管理员邮件地址,它会给管理员发邮件SMTP_HOST = localhostSMTP_PORT = 25SMTP_FROM = DenyHosts &lt;nobody@localhost&gt;SMTP_SUBJECT = DenyHosts ReportAGE_RESET_VALID=5d #用户的登录失败计数会在多久以后重置为 0，(h 表示小时，d 表示天，m 表示月，w 表示周，y 表示年)AGE_RESET_ROOT=25dAGE_RESET_RESTRICTED=25dAGE_RESET_INVALID=10dRESET_ON_SUCCESS = yes #如果一个 ip 登陆成功后，失败的登陆计数是否重置为 0DAEMON_LOG = /var/log/denyhosts #自己的日志文件DAEMON_SLEEP = 30s #当以后台方式运行时，每读一次日志文件的时间间隔。 启动 12/etc/init.d/daemon-control start #启动 denyhostschkconfig daemon-control on #将 denghosts 设成开机启动 启动命令（yum 安装，已默认配好） 123service denyhosts startservice denyhosts stopservice denyhosts status 安装这两天，我完成了 CentosInit 项目，一个高度自定义的 Centos 初始化脚本。 欢迎 Star PR ! 如果你想快速配置以上安全措施，请执行以下命令： 通过 curl 1ONLY_SECURE=Y sh -c \"$(curl -fsSL https://tomotoes.com/Centos-init/install.sh)\" 通过 wget 1ONLY_SECURE=Y sh -c \"$(wget https://tomotoes.com/Centos-init/install.sh -O -)\" 基本介绍脚本功能一共分为四大类: 初始化配置（update） 123456789updateLanguageupdateTimeupdateLanguageupdateTimeupdateDNSupdateYumSourceupdateHostnameupdateUlimitupdateCoreConfig 安装常用软件（install） 123456789101112installCommonSoftinstallGitinstallViminstallZshinstallNodeinstallNpmPackagesinstallPythoninstallPipPackagesinstallDockerinstallNginxinstallCcatinstallShadowSocks 配置安装后的软件（config） 1234567configVimconfigZshconfigGitconfigNodeconfigDockerconfigNginxconfigShadowSocks 必要的安全配置（secure） 基础项 12345deleteOrLockUnnecessaryUsersAndGroupssetPrivilegescloseCtrlAltDelcloseIpv6closeSELinux 高阶项 1234updateSSHPortuseKeyLoginuseIptablepreventCrackingPassword 用户相关项 1234getUserInfoaddUserjoinWheelGroupbanRootLogin 单独功能安装如果你想安装某一种功能( Update | Install | Config | Secure ) 请参考以下案列: 12345# 在安装命令前设置 ONLY_UPDATE=Y 即可只安装 update 服务ONLY_UPDATE=Y sh -c \"$(curl -fsSL https://tomotoes.com/Centos-init/install.sh)\"# Install and ConfigONLY_INSTALL=Y ONLY_CONFIG=Y sh -c \"$(curl -fsSL https://tomotoes.com/Centos-init/install.sh)\" 交互模式你也设置设置交互模式，在交互模式下，可高达自定义化你想使用的功能。 每执行完一项功能，都会询问你下一步。 使用功能的方法如下: 12# 在安装命令前设置 INTERACTIVE=YINTERACTIVE=Y sh -c \"$(curl -fsSL https://tomotoes.com/Centos-init/install.sh)\" 结束语希望上面的这些措施可以帮助你加强服务器的安全。 转载本站文章请注明作者和出处 一个坏掉的番茄，请勿用于任何商业用途。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tomotoes.com/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tomotoes.com/blog/tags/Linux/"},{"name":"信安","slug":"信安","permalink":"https://tomotoes.com/blog/tags/%E4%BF%A1%E5%AE%89/"}]},{"title":"Vim 修炼秘籍之语法篇","date":"2018-03-18T08:44:05.000Z","path":"/grammar-of-vim-cultivation-cheats/","text":"欲练此功，必先自宫。 前言 少年，我看你骨骼精奇，是万中无一的武学奇才，维护世界和平就靠你了，我这有本秘籍《Vim 修炼秘籍》，见与你有缘，就十块卖给你了！ —— 本秘籍建议零售价：10 元 如果你是一名 Vimer，那么恭喜你，你的 Vim 技能马上要升级了 😈！ 如果你之前不了解过 Vim ，那么也没关系，本文就当成学英语语法了！ 好，废话不多说，秘籍送上。 ps: 建议先熟悉一遍 Vim 修炼秘籍之命令篇，本秘籍食用更佳 正文核心秘诀Vim 功法之究极总结： （操作次数）+ 操作行为 + 操作范围 下面，我会将此秘诀 亲自传授于你。 秘诀解析先列一些常用的 Vim 招式给你瞧瞧，看你是否是传说的练武奇才： 123456c2w —— 删除当前光标后紧邻的两个单词，并转换为普通模式dip —— 删除当前光标所处的一段内容y3f{char} —— 从当前字符，一直复制到第三个 {char} 字符&gt;G —— 当前行到结尾，整体缩进一个 &lt;Tab&gt;v`{mark} —— 从当前字符，选择到 {mark} 标记位置cit —— 删除当前光标所处标签中的内容 如果把招式看成语言，解析其语法，不难发现一个共同点： 每个招式必须包括 谓语（操作行为） 与 宾语（操作对象） 好，既然有了线索，我这就带你各个击破！ 谓语（操作行为）众所周知，谓语是 动词词性的。 在 Vim 功法中，常用的动词如下： c 删除内容，进入普通模式 d 删除 y 复制 v 选择 &gt;,&lt; 缩进 = 智能缩进 gu,gU,g~ 改变内容大小写 宾语（操作对象）宾语代表的是操作对象，而在 Vim 中，所需操作的对象即是 操作的范围。 而常用的操作范围命令如下： w 从当前位置，到下一个单词首字母，单词由特殊字符（”.等）作为间隔 内容： .main {xxx} , 光标处在字符 m 招式：caw 结果：. {xxx} W 从当前位置，到下一个单词首字母，单词由空格作为间隔 内容： .main {xxx} , 光标处在字符 m 招式：caW 结果： {xxx} e 从当前位置，到本单词尾字母 ge 从当前位置到上一个单词尾字母 b 通常代替括号中的内容 上一个单词首字母 p 段落 paragraph s 句子 sentence t 标签中的内容 B 通常代替花括号中的内容 符号 {) \"'&lt; 代表的就是 该符号中的内容 G,gg 结尾，开头 j,k,h,l 上下左右 /{word}&lt;Enter&gt; 从当前字符 到下一个 word 之间的内容 f{char} 从当前字符到下一个 char 字符之间的内容 `mark 从当前字符到 mark 标记 之间的内容 双写动词，操作范围默认是当前行 dd 删除当前行 cc 删除当前行 并转换为普通模式 &gt;&gt; 缩进当前行 v 动词例外，使用 V 选中当前行。 gU 命令是一种特殊情况，可用 gUU 来使它作用于当前行。 数词（操作次数）假如现在有个任务，让你删除两个单词，你会怎么做？ d2w 删除两个单词 2dw 执行两次删除单词的命令 虽然这两式结果相同，但意义却有所差别， 数词灵活多变，可放在 谓语（操作行为）前，又可放在 宾语（操作对象）前， 放在 谓语前，代表操作次数， 放在 宾语前，代表操作范围的扩张次数 介词（修饰范围）常用的介词就两个：i(inside) ， a(around) 举例说明：光标处在字符 c (main)(div class=\"vim-test\" I am Vimer! div)(main) 分别操作： dab 结果：(main)(main) dib 结果：(main)()(main) 顾名思义，i 就是内部的内容，a 就是连同包裹的内容 一起干掉。 招式实战我已经教授了你 Vim 秘籍的基本功 ：（操作次数）+ 操作行为 + 操作范围 现在，利用你所学，来实战巩固吧。 将下面标签中的内容修改了: I am Vimer! (光标所处 字符 c ) (div class=\"vim-test\")you are Bimer!(div) 修改下面字符串为 https://tomotoes.com ！（光标所处 第一个 w 字符） https://www.tomotoes.com 将文件 所有内容格式化，写出 你认为的命令 将下面字符串改为 I am Vimer （光标所处 I 字符） I am VIMER 将下面字符串的每个字符替换为 ‘!’ I love github and juejin 等待你的评论答案。 结束语好的功夫是练出来的，请你以后务必勤加练习。 好了，Vim 语法先告一段落，希望本文能给你带来帮助。 如果你想了解 Vim 其他方面 如：Ex 命令，寄存器等，请关注我的后续文章。 转载本站文章请注明作者和出处 tomotoes.com，请勿用于任何商业用途。","categories":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Vim","slug":"Vim","permalink":"https://tomotoes.com/blog/tags/Vim/"}]},{"title":"囚思","date":"2018-03-08T01:51:13.000Z","path":"/prison-thoughts/","text":"年少时写的一首小词。 囚思 一往情深深几许？ 二心紧绑，三年孤依不言弃。 炼金情，苦思忆， 岁月多别离， 人渐消沉天渐熄， 思绪囚心屿。 于 2016.05.28 19:28 所作 （正和她处在异地恋） #post-content > p:nth-child(1),#post-toc,#囚思{display:none}#post-content>p,#post-content>h3{text-align:center;border-bottom:none}.post-count-custom{display:none}#post-content>h3{margin-bottom:15px;margin-top:20px;border-bottom:dashed #efefef 5px;}.post {line-height:180% !important;font-size:105%;letter-spacing:4px;border-radius:20px;text-shadow: rgb(158, 158, 158) 0px 0px 1px;color:hsl(250,13%,30%);padding:0 20px;transition:all .3s ease-in;}.post:hover{transform:translateY(-1px);transition:all 0.2s;}@media screen and (max-width:760px){.post{letter-spacing: 1px;}}","categories":[{"name":"诗词","slug":"诗词","permalink":"https://tomotoes.com/blog/categories/%E8%AF%97%E8%AF%8D/"}],"tags":[{"name":"诗词","slug":"诗词","permalink":"https://tomotoes.com/blog/tags/%E8%AF%97%E8%AF%8D/"}]},{"title":"你有所不知的 margin 属性","date":"2018-02-23T09:41:43.000Z","path":"/you-dont-know-the-margin-attribute/","text":"你真的了解的 margin 属性吗？ 前言致谢本文总结于 张鑫旭老师的 CSS 深入理解之 margin 课程，感谢张老师的辛苦付出！ 难学的 CSS作为前端狗的我们，每天都要和网页打交道。当 UI 将设计稿发给你时，CSS 的知识便显得尤为重要。而 CSS 这一标记性的语言，却时常让我很头疼：毫无逻辑性，并充满了各种坑爹的潜规则 ，以至于每次做项目时，大部分时间精力都浪费在了调整布局与样式上，详情可点击知乎上的为什么 CSS 这么难学？问题，道出了我的心声 :( 但谁叫我们是吃这碗饭的呢，不管怎样，有困难必须迎面解决，学好 CSS ，向张老师看齐！ 正文margin 算是性格刚烈的属性了，下面，我将从各个方面讲解 margin 的可怕之处。 元素尺寸的影响 通常一个元素的尺寸可分为：可视尺寸 与 占据尺寸 可视尺寸 - clientWidth (border - padding - size) 占据尺寸 - outerWidth (border - margin) 元素尺寸示例图 margin 又是怎样影响这两个尺寸的呢？ 首先，两个尺寸都需满足一定的条件。 可视尺寸的影响条件 适用于 没有设定 width/height 的块级元素 (宽高设死了，怎么会影响呢？) 其中不包括 float absolute fixed 元素 ，inline 水平 ，table-cell 元素 只适用于水平方向尺寸（margin-left/margin-right） 占据尺寸的影响条件 适用于 block/inline-block 水平元素 适用于 任何方向 与 width/height 值无关 inline 元素只影响水平方向 (后面会提到) 影响示例 margin 影响元素的可视水平尺寸 See the Pen margin 的可视尺寸 by Simon Ma (@Tomotoes) on CodePen. margin 影响占据尺寸 ，这个可以说是 margin 的本命技能了，就不举例了。 百分比单位通常而言，margin 的单位中，百分比单位最容易让人头晕。 普通元素的百分比 margin 都是相对于 容器的宽度 计算的 12345678910111213#parent { margin: 20px 400px; width: 100px; height: 200px;}#child { /* 等价于 margin: 5% * 父元素的宽度 10% * 父元素的宽度; */ margin: 5% 10%; /* 父元素的宽度 * 50% */ width: 50%; /* 父元素的高度 * 50% */ height: 50%;} 123&lt;div id=\"parent\"&gt; &lt;div id=\"child\"&gt;&lt;/div&gt;&lt;/div&gt; 绝对定位的百分比 margin 是相对于 第一个具有定位属性的祖先元素的宽度 计算的(relative/absolute/fixed) 12345678910#parent { width: 100px;}#child { /* 注意子元素已增加绝对定位，则百分比按照定位属性的祖先元素的宽度计算， 本例中是浏览器视口 */ position: absolute; /* 等价于 margin: 5% * 父元素的宽度 10% * 父元素的宽度; */ margin: 5% 10%;} 123&lt;div id=\"parent\"&gt; &lt;div id=\"child\"&gt;&lt;/div&gt;&lt;/div&gt; 重叠详解重叠可谓是 margin 中的最重要的潜规则了。 发生情景 相邻的兄弟元素 父级和第一个/最后一个子元素 空的块级元素（自己和自己） 重叠条件 块级元素 （不包括 float 和 absolute 元素） 不考虑 writing-mode，只发生在垂直方向 （margin-top/margin-bottom） 父子 重叠条件 margin-top 重叠 父元素 非格式化上下文元素 没有设置 overflow:hidden 父元素没有 border-top 设置 父元素没有 padding-top 设置 父元素和第一个子元素之间没有 inline 元素分割 margin-bottom 重叠 父元素 非格式化上下文元素 没有设置 overflow:hidden 父元素没有 border-bottom 设置 父元素没有 padding-bottom 设置 父元素和第一个子元素之间没有 inline 元素分割 父元素没有 height ，min-height，max-height 限制 空的块级元素 margin 重叠条件 元素没有 border 设置 元素没有 padding 设置 里面没有 inline 元素 没有 height，或者 min-height 计算规则 正正取大值 123456#top { margin-top: 30px;}#bottom { margin-bottom: 20px;} 123&lt;div id=\"bottom\"&gt;&lt;/div&gt;&lt;div id=\"top\"&gt;&lt;/div&gt;两个元素垂直距离为 : #top 元素的 margin-top 值 正负值相加 123456#top { margin-top: -30px;}#bottom { margin-bottom: 20px;} 123&lt;div id=\"bottom\"&gt;&lt;/div&gt;&lt;div id=\"top\"&gt;&lt;/div&gt;两个元素垂直距离为: #top 元素的 margin-top 值 加上 #bottom 元素的 margin-bottom 值 负负最负值 123456#top { margin-top: -30px;}#bottom { margin-bottom: -20px;} 123&lt;div id=\"bottom\"&gt;&lt;/div&gt;&lt;div id=\"top\"&gt;&lt;/div&gt;两个元素垂直距离为 : #top 元素的 margin-top 值 父级和第一个/最后一个子元素 发生重叠 给子元素设置垂直方向的 margin ，等同于 给父元素设置相同的垂直方向的 margin 属性， 也就是说 父子元素发生 margin 重叠时， 它们俩共用一个 margin 属性 重叠意义 连续段落或列表之类，如果没有 margin 重叠，排版会不自然。 页面中任何地方，嵌套或直接放入任何空的 div，都不会影响原来的布局。 遗落空的任意多个 p 元素，不会影响原来的阅读排版。 margin auto当你使用 margin auto 时，就应该联想到一个词 ：填充 一个没有设置宽高的块级元素，会自动填充宽度 如果 一侧是定值，一侧是 auto，则 auto 为剩余空间的大小 如果两侧均是 auto，则平分 剩余空间 示例如下： 123456789&lt;style&gt; #demo { width: 500px; margin-right: 100px; /* margin-left: 100vw - margin-right - width*/ margin-left: auto; }&lt;/style&gt;&lt;div id=\"demo\"&gt;&lt;/div&gt; margin:auto 0 !== 垂直居中以上，我们可得当一个块级元素设置了 margin: 0 auto 可以实现水平居中， 而为什么 margin:auto 0 不会垂直居中？ 答：一个块级元素会自动填充可用的水平尺寸，但不会填充垂直尺寸，是因为其根本没有任何可用的垂直空间。也就是说 margin: 0 auto , 总是有尺寸可以来填充的！ 而 margin: auto 0 是没有任何尺寸的可以来填充的。 失效情况当子元素的宽度大于父元素的宽度 ，是无法通过 margin: 0 auto 实现居中的 因为，这个时候已经没有任何空间可以填充了，当宽度超出父元素时，margin 已经为负值了。 垂直居中 writing-mode 与垂直居中 123456.father { writing-mode: vertical-lr; /* 更改流的方向为 垂直方向 */}.son { margin: auto;} 123&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; 绝对定位元素 1234567891011.parent { position: relative;}.child { position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;} 123&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt; 失效情景 inline 水平元素的垂直 margin 无效（margin-top/margin-bottom） margin 重叠发生 绝对定位元素非定位方位的 margin 值 “无效” 因为 绝对定位元素 脱离了文档流，与相邻元素没有关系，所以它不可能像普通元素一样，设置 margin，推走其他元素 margin 鞭长莫及 因为 有某些元素破坏了 文档流，设置了 float absolute，造成了假象，margin 不会根据 这些破坏元素作为标准 display:table-cell/display:table-row 等声明的 margin 无效！某些替换元素除外，根据各个浏览器的实现方式作为区分。比如，给 button 元素声明 display:table-cell，但在 chrome 中,button 的 display 属性是 inline-block 。 内联特性导致 margin 失效 margin-top: 负无穷， 但是，小到 1em 便无效了。 因为它是内联元素，默认是基线对齐，x 字母下边缘对齐，margin 值再大，也不会起作用。 示例如下： See the Pen margin 负无穷情景解析 by Simon Ma (@Tomotoes) on CodePen. 其他属性 margin-start 正常流向，margin-start 等同于 margin-left，两者重叠不相加 如果水平流向是从右向左，margin-start 等同于 margin-right 在垂直流下 ( writing-mode:vertical-*; ) margin-start 等同于 margin-top margin-end 与 margin-start 相对 margin-before 默认情况等同于 margin-top margin-after 默认情况等同于 margin-bottom margin-collapse margin-collapse:collapse; (默认值) 发生重叠 margin-collapse:discard; 取消重叠，margin 重叠部分为 0 ，没有 margin margin-collapse:separate; 不发生重叠，margin 重叠部分为 margin-top + margin-bottom 结束语margin 课程就到此结束了，再次感谢张鑫旭老师的辛苦付出！ 本系列就持续更新中，期待你的关注~ 转载本站文章请注明作者和出处 tomotoes.com，请勿用于任何商业用途。 .post-toc-level-4{display:none;}","categories":[{"name":"前端","slug":"前端","permalink":"https://tomotoes.com/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomotoes.com/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://tomotoes.com/blog/tags/CSS/"}]},{"title":"Git 修炼手册","date":"2018-01-27T01:58:00.000Z","path":"/git-training-manual/","text":"Git 命令大汇总。 入门配置用户信息 git config –global user.name Simon 设置自己的用户名 git config –global user.email jinmaup@gmail.com 设置自己的邮箱 查看配置git config –list 查看自己 git 的配置信息 设置编辑器git config –global core.editor vim 当你用 git 编辑文件时，编辑文件的文本编辑器会默认调用 vim 文本着色git config –global color.ui true 可为大部分 git 的代码布上颜色 基础命令建立版本库 git init 当前路径文件 初始化为 Git 仓库（可以发现 当前路径增加了.git 文件夹） git init 文件夹名 新建一个文件夹，并将其初始化为 Git 代码库 文件添加到暂存区 git add . 把当前目录所有未追踪文件，已修改的文件，添加到暂存区 (不包括被删除的文件) git add 文件（夹）名 把特定文件（夹）添加到暂存区 git add -A 提交所有的文件操作到暂存区 git add -u 提交已修改的文件,被删除的文件（不包括新文件） git add -p 交互式的缓存提交，会提供多个选项来自定义提交内容、方式 文件添加到本地仓库 git commit -m”commit message” 把暂存区的所有文件添加到本地仓库，-m”提交信息” （越详细越好） git commit 文件（夹）名 -m”commit message” 把特定文件（夹）添加到本地仓库，-m”提交信息” （越详细越好） git commit -am”commit message” 针对已经被追踪的文件，可以直接添加到本地仓库，不用先 add 在 commit. git commit –amend -m”commit message” 利用本次 commit 重写上一次 commit git commit –amend –no-edit 利用本次 commit 重写上一次 commit 不会重写上次 commit 的提交信息 仓库状态获取git status 可以立即获取本地仓库状态 以及 git 的步骤提示，建议多使用此命令 版本回退 git reset –hard HEAD 将工作区，暂存区，本地仓库恢复到上一个版本（–hard） git reset –soft HEAD^^^ 将本地仓库恢复到上三个版本,不会修改暂存区，工作区（–soft） git reset –mixd HEAD~5 将暂存区，本地仓库恢复到上五个版本，不会修改工作区（–mixd，默认） git reset –hard commitID 将工作区，暂存区，本地仓库恢复到上指定版本 其中 commitID 就是每一次 commit 的版本号，可以使用 git reflog 获取 撤销暂存 git reset HEAD file.txt 撤销 file.txt 的 add 操作，使其变成不跟踪状态 git reset HEAD^ file.txt 将上一次提交版本的 file.txt 重新置入缓存区 撤销工作区 git checkout – file.txt （只针对未追踪文件）用历史中的 file.txt 替换现有工作区的 file.txt 如果文件增加到暂存区后 又进行了修改，那么执行命令后 将回到暂存区文件状态 git checkout HEAD – file.txt 用最后一次提交版本中的 file.txt 替换现有工作区的 file.txt git checkout commitID – file.txt 用特定版本的 file.txt 替换现有工作区的 file.txt 撤销提交git revert commitID 撤销指定版本的 commit，并将此操作生成一个全新的 commit 并提交 文件操作增 touch touch 文件名 ： 新建文件 mkdir mkdir 文件夹名： 新建文件夹 vim vim 文件名 ： 新建文件，并用 vim 模式打开该文件进行编写 git init git init 文件夹名：新建一个文件夹，并将其初始化为 Git 代码库 printf printf ‘content’ &gt; 文件名 ：新建一个文件，并把 content 注入其内容 echo echo ‘content’ &gt; 文件名 ：新建一个文件，并把 content 注入其内容 删 rm rm 文件名 : 删除文件 clean git clean -f 文件名 ：删除未跟踪文件 改 vim vim 文件名 ： 打开文件，并用 vim 模式进行修改 mv mv 选定文件名 新的文件名：把选定文件名 修改为 新的文件名 printf printf ‘content’ &gt; 文件名 ： 将 content 替换 文件原有内容 echo echo ‘content’ &gt; 文件名 ： 将 content 替换 文件原有内容 查 pwd 得到当前路径 cd cd 路径 ：进到某一文件路径 cd .. : 回退文件路径 cd : 回到默认的路径 cat cat 文件名：查看该文件的内容 ls 查看该目录下的文件列表（不包括隐藏文件） ls -a 查看该目录下的文件列表（包括隐藏文件） show git show : ：展示任意分支某一文件的内容 分支操作查看分支 git branch 列出本地分支 git branch -r 列出远端分支 git branch -a 列出所有分支 git branch -v 查看各个分支最后一个提交对象的信息 git branch –merge 查看已经合并到当前分支的分支 git branch –no-merge 查看为合并到当前分支的分支 git remote show origin 可以查看 remote 地址，远程分支 新建分支 git branch name 新建一个名为 name 的分支 git checkout -b name 新建一个名为 name 的分支，并自动切换为该分支 git branch [branch] [commit] 新建一个分支，指向指定 commit git branch –track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立追踪关系 删除分支 git branch -d name 删除一个名为 name 的分支 git branch -D name 强制删除一个名为 name 的分支 git push : 删除远程分支 git push origin –delete 删除远程分支 切换分支 git checkout name 切换一个名为 name 的分支 git checkout - 切换上一个分支 重命名分支 git branch -m name 将当前所在分支命名为 name 标签新建标签 git tag [tag] 新建一个 tag 在当前 commit git tag [tag] [commit] 新建一个 tag 在指定 commit git tag v0.9 commitID 对某次提交新建标签 查看标签 git tag 列出所有 tag 删除标签 git tag -d [tag] 删除本地 tag git push origin :refs/tags/ 可以删除一个远程标签 推送标签 git push origin –tags 一次性推送全部尚未推送到远程的本地标签 git push origin 可以推送一个本地标签 远程仓库 git remote 显示所关联的远程仓库 git remote -v 显示更详细信息 git remote add origin git@server-name:path/repo-name.git 关联一个远程库 git remote rm name 删除一个远程库 git remote rename 将远程连接从 重命名为 合并 git rebase master 将 master 分之上超前的提交，变基到当前分支 git rebase –interactive 交互模式，修改 commit git rebase –continue 处理完冲突继续合并 git rebase –skip 跳过合并 git rebase –abort 取消合并 查看汇总查看信息 git whatchanged –since=’2 weeks ago’ 查看两个星期内的改动 git log –follow [file] 显示某个文件的版本历史 git log –author=”John” 它会显示所有作者叫 John 的提交 get log –after=”yesterday” 查看昨天的历史信息 git log -3 展示最近 3 次历史信息 git log –graph 可以看到分支合并图 修改历史git rebase -i commitID 将 pick 替换成 r , 然后回车，vi 退出可以使用 :x 修改 git 的历史记录的提交信息 查看文件 git diff HEAD – readme.txt 可以查看工作区和版本库里面最新版本的区别 git diff –staged 显示暂存区（已经 add）的文件和版本库文件的比较 git ls-files 查看在暂存区的文件 删除暂存 git rm –cached 文件名 把文件从暂缓区 返回至 工作区 其他忽略文件echo node_modules/ &gt;&gt; .gitignore 添加忽略文件 打包 git archive master –format=zip –output=master.zip 将 Master 分支打包 git bundle create 将历史记录包括分支内容打包到一个文件中 git clone repo.bundle -b 从某个 Bundle 中导入 工作区 git stash 将工作区现场（已跟踪文件）储藏起来 git stash list 查看保存的工作现场 git stash apply 恢复工作现场 git stash drop 删除 stash 内容 git stash pop 恢复的同时直接删除 stash 内容 git stash apply stash@{0} 恢复指定的工作现场 查找内容 git grep “Hello” 从当前目录的所有文件中查找文本内容 git grep “Hello” v2.5 在某一版本中搜索文本 帮助git help -a .post-toc-level-4{ display:none }","categories":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"Git","permalink":"https://tomotoes.com/blog/tags/Git/"}]},{"title":"网站必备之简繁切换","date":"2018-01-26T10:17:31.000Z","path":"/simplified-chinese-and-traditional-chinese-switching/","text":"一个优秀网站能够更好地照顾不同的用户。 前言&nbsp;&nbsp;&nbsp;&nbsp;一个优秀的网站为了能够更好地照顾不同的用户，一般都会提供简繁两种版本字体切换，提高用户的体验。例如 : Hexo 官网 。之所以 Hexo 能得到了不少内地忠实粉丝的追捧，是因为 Hexo 的官网不仅提供了适合台湾同胞（作者是来自台湾的）阅读的繁体中文版，还为我们大陆用户提供了简体中文版，照顾了我们平时的写作习惯。同样，我们也可以提供繁体版来照顾那些使用繁体字的台湾、港澳同胞。 &nbsp;&nbsp;&nbsp;&nbsp;下面，我将由浅入深地讲解：如何使用 35 行代码，让网站支持简繁切换功能。 正文&nbsp;&nbsp;&nbsp;&nbsp;一般而言，网站上实现两种字体的切换，需要先准备两种字体库，而基本逻辑通常是：识别当前字体，然后根据当前字体去相对的字体库中去寻找另一字体，从而进行字体的替换，处理起来不但麻烦而且耗时。 &nbsp;&nbsp;&nbsp;&nbsp;有没有一种方法，可以绕开这些弯路呢？ &nbsp;&nbsp;&nbsp;&nbsp;答案是有的，我们可以利用数组索引的特性来完成，具体逻辑如下： 12345678910function Exchange(text){ const Simplified = \"万与丑\"; const Traditional = \"萬與醜\";//翻译成简体：万与丑 let result,findIndex; for(let i=0;i&lt;text.length;++i){ findIndex = Simplified.indexOf(text[i]); result += findIndex === -1 ? text[i] : Traditional[j]; } return result;} &nbsp;&nbsp;&nbsp;&nbsp;系统来讲，切换字体的大体过程 可分为 3 大步骤： 得到页面的字体内容 切换为简繁字体 保存状态与切换状态 得到页面的内容&nbsp;&nbsp;&nbsp;&nbsp;毫无疑问，我们所要切换的内容便是页面中的汉字，众所周知，判断汉字可以使用正则表达式/[\\u4e00-\\u9fa5]/g，而我们在第一步 所面临的最大问题便是：如何得到页面中所有的字体内容。分析网页中结构可得，显示给用户的内容一般都在body标签中或者其各个子标签中，我们该如何获取这些包裹着内容的标签呢？又该如何判断 元素与所需字体呢？ &nbsp;&nbsp;&nbsp;&nbsp;下面，我将带你学习两个原生 JS 的 API 。 childNodes childNodes 属性返回节点的子节点集合，包括 元素节点、文本内容、注释、属性等。 1document.body.childNodes;/* 获得 body 元素的子节点集合*/ &nbsp;&nbsp;&nbsp;&nbsp;可以想象到，我们先将 document.body.childNodes 作为入口 循环遍历，然后再如法炮制的递归各个元素，便可得到 body 标签中 所有的 DOM 节点以及节点中所需的文本内容。 nodeType nodeType 属性返回以数字值返回指定节点的节点类型。 如果节点是元素节点，则 nodeType 属性将返回 1。 如果节点是文本节点，则 nodeType 属性将返回 3。 1document.body.nodeType === 1;/* true */ &nbsp;&nbsp;&nbsp;&nbsp;有了 nodeType 作为当前元素的判断，我们便可轻松的分离出 DOM 节点与 文本节点，从而来进行不同需求的操作。 &nbsp;&nbsp;&nbsp;&nbsp;大体逻辑如下： 12345678910function translateBody(obj) { let objs = (obj ? obj : document.body).childNodes; for (let i = 0; i &lt; objs.length; i++) { if (objs[i].nodeType === 3) { objs[i].textContent = Exchange(objs[i].textContent); } else if (objs[i].nodeType === 1 ) { translateBody(objs[i]); } }} &nbsp;&nbsp;&nbsp;&nbsp;这样，我们便得到了所需要的文本内容。下面，我们将进行 Exchange 函数的编写。 切换简繁字体&nbsp;&nbsp;&nbsp;&nbsp;毫无疑问，切换字体最大的困难，就是索引相同的字体库了。所幸，我从网上寻得了前辈总结的资源，欢迎大家使用。 12const Simplified = \"万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾\";const Traditional = \"萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽\"; &nbsp;&nbsp;&nbsp;&nbsp;根据上面的总结，Exchange 函数编写如下： 12345678910111213function Exchange(text) { let result = '', j, s = \"万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾\", t = \"萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽\"; if (!currentEncoding) {//如果当前是 繁体切换为简体，进行交换。 j = s; s = t; t = j; } for (let i = 0; i &lt; text.length; i++) { j = s.indexOf(text[i]); result += j === -1 ? text[i] : t[j]; } return result;} 保存与切换状态保存状态&nbsp;&nbsp;&nbsp;&nbsp;相信学习过 HTML5 的同学都对localStorage有一点的了解吧，我们就利用它来进行当前状态的保存。当用户进入网站时，读取曾经保存的状态，而每当状态的切换，我们都要刷新当前存储的值。另外，值得注意得是，localStorage中存储的是字符串类型的值，必须对其进行转换，才能使用，如下所示： 123if (localStorage.getItem(\"targetEncoding\") === \"false\") { /* doSomething... */} 切换状态&nbsp;&nbsp;&nbsp;&nbsp;目前我们的需求是简繁字体切换，充其量就是两种状态的保存，用 布尔类型 一定是没错的。 1let currentEncoding = targetEncoding = true; &nbsp;&nbsp;&nbsp;&nbsp;我们定义了两个变量，当 currentEncoding的值为 true 时，说明 当前字体为简体，反之为繁体。而targetEncoding永远指向 currentEncoding下一个要切换的状态。 &nbsp;&nbsp;&nbsp;&nbsp;当切换状态时， 逻辑如下： 12currentEncoding = targetEncoding;targetEncoding = !targetEncoding; &nbsp;&nbsp;&nbsp;&nbsp;Ok ，大体过程就搞定了，下面是源码~ 源代码点击显/隐源文件 123456789101112131415161718192021222324252627282930313233343536let currentEncoding = targetEncoding = true;let stopDOM = [\"BR\",\"TIME\",\"IMG\",\"CANVAS\",\"SCRIPT\"];if (localStorage.getItem(\"targetEncoding\") === \"false\") { targetEncoding = false; translateBody();}function translateBody(obj) { let objs = (obj ? obj : document.body).childNodes; for (let i = 0; i &lt; objs.length; i++) { if (objs[i].nodeType === 3 &amp;&amp; /[\\u4e00-\\u9fa5]/g.test(objs[i].textContent)) { objs[i].textContent = Exchange(objs[i].textContent); } else if (objs[i].nodeType === 1 &amp;&amp; !stopDOM.includes(objs[i].tagName)) { translateBody(objs[i]); } }}function Exchange(text) { let result = '', j, s = \"万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾\", t = \"萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽\"; if (!currentEncoding) { j = s; s = t; t = j; } for (let i = 0; i &lt; text.length; i++) { j = s.indexOf(text[i]); result += j === -1 ? text[i] : t[j]; } return result;}/* 调用函数: button.onclick = translatePage() */function translatePage() { currentEncoding = targetEncoding; targetEncoding = !targetEncoding; localStorage.setItem(\"targetEncoding\", targetEncoding); translateBody();} 结束语转载本站文章请注明作者和出处 tomotoes.com，请勿用于任何商业用途。","categories":[{"name":"前端","slug":"前端","permalink":"https://tomotoes.com/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://tomotoes.com/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://tomotoes.com/blog/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"神奇的位运算","date":"2018-01-25T08:32:02.000Z","path":"/magic-bit-operation/","text":"位运算在计算机领域的作用可谓举足轻重。 前言&nbsp;&nbsp;&nbsp;&nbsp;首先，我们要了解一个概念：程序中的所有数在计算机内存中都是以二进制的形式储存的。而位运算，就是直接对在内存中的二进制位进行操作，跳过了 程序转义成二进制的这一步骤，对编译时间有所提高，但带来的缺点也很明显，程序的可读性变低了。 &nbsp;&nbsp;&nbsp;&nbsp;掌握位运算 是一位程序员的基本素养，位运算在计算机领域的作用可谓举足轻重。 &nbsp;&nbsp;&nbsp;&nbsp;下面我将讲解 位运算的大体方法以及一些基本的应用。 正文and 运算 只有对应的两个 二进制数，均为 1，结果才为 1，否则为 0 &amp; 1判断 n 的第 m 位数。 介绍两个重要应用，来证明其含义： (n &gt;&gt;m ) &amp; 1 判断 整数 n 的二进制 第 m 位 是否 为 1 或者 为 0 n 的第 m 位数，如果为 1 ，1&amp;1 就返回 1 ，如果为 0，0&amp;1 就返回 0 判断 奇偶性 如果 n 为奇数，辗转相除 2，最后的余数 必定为 1，如果 n 为偶数，辗转相除 余数必定为 0 也就是说，n 为奇数，n&amp;1 等价于 1&amp;1 ，返回 1，n 为偶数，n&amp;1 等价于 0&amp;1，返回 0 &amp; 0将 n 的第 m 位数，重置为 0 基本应用：n &amp; ~(1 &lt;&lt; m) 1 &lt;&lt; m 定位到 n 的第 m 位数 ~(1 &lt;&lt; m) 将 1 进行非运算，变为 0，其他剩下的 m 位，变成 1，而 &amp;1，是无实际作用的 n &amp; 0 ：&amp; 按位与运算 只有对应的两个数 全部为 1 时，结果才为 1，而&amp;0，返回值一定为 0 or 运算 只有对应的两个 二进制数，均为 0，结果才为 0，否则为 1 | 1将 n 的第 m 位数，重置为 1 基本应用：n | (1 &lt;&lt; m): 1 &lt;&lt; m定位到 n 的第 m 位数 n | 1n 的第 m 位数 进行 |1 操作 其返回值必定为 1！ 因为|只有，两个数都为 0 时，结果才为 0 | 0无实际作用 一定要清楚， 是 n 的第 m 位数 在进行操作，其他 位数操作，根本无 影响 因为，其他位数，是 在进行 “| 0” 操作，而所谓的 |0 操作，与 &amp;1 操作，毫无差别。 假设 k=n 的第 m 位数，k = 1 ，k|0 = 1|0 = 1，k = 0，k|0 = 0|0 = 0，所谓 无实际作用。 但是要注意一点，我说的 0 是在二进制数中的 0，有实际含义的 0，不是补 0 的 0 所以，可以感性的认识到，| 0 与 &amp; 1 以及 下文的 ^ 0，都是无实际作用的 xor 运算 只有对应的两个 二进制数相等时，结果才为 0，否则为 1 ^ 1将 n 的第 m 位数，取反 基本应用：n ^ (1 &lt;&lt; m) 1 &lt;&lt; m ： 定位到 n 的第 m 位数 n ^ 1，我们要知道，^ (异或）：不相等为 1，相等为 0 而 ^1：如果 n 的第 m 位数 为 1，1^1 返回值为 0，如果 n 的第 m 位数 为 0，0^1 返回值 为 1 所以，^1 的重要作用，就是 与之相反的作用 ^ 0无实际作用 假定 整数 k 为 0，k^0 = 0^0 = 0 ; 假定整数 k 为 1，k^0 = 1^0 = 1 所以说，无论怎么变化，^0 都是无实际作用的 shl &amp; shr 运算 左移运算符 “&lt;&lt;” 表达式：a &lt;&lt; b a&lt;&lt;b 的值是：将 a 各二进位全部左移 b 位后得到的值。左移时，高位丢弃，低位补 0。 实际上，左移 1 位，就等于是乘以 2，左移 n 位，就等于是乘以 2n。 而左移操作比乘法操作快得多。12345例如:9 &lt;&lt; 49的二进制形式：0000 0000 0000 0000 0000 0000 0000 1001因此，表达式“9&lt;&lt;4”的值，就是将上面的二进制数左移4位，得：0000 0000 0000 0000 0000 0000 1001 0000即为十进制的144 , 而 9*2的4次幂 = 9*16 = 144. 右移运算符 “&gt;&gt;” 表达式：a &gt;&gt; b a&gt;&gt;b 的值是：将 a 各二进位全部右移 b 位后得到的值。右移时，移出最右边的位就被丢弃。 对于有符号数，如 long,int,short,char 类型变量，在右移时，符号位（即最高位）将一起移动，并且大多数 C/C++编译器规定，如果原符号位为 1，则右移时高位就补充 1，原符号位为 0，则右移时高位就补充 0。12实际上，右移 n 位，就相当于左操作数除以2n，并且将结果往小里取整。例如：-25 &gt;&gt; 4 = -2 -2 &gt;&gt; 4 = -1 18 &gt;&gt; 4 = 1 应用对 2 的整数幂进行模运算123456789101112#include &lt;stdio.h&gt;int main(){ int n,k; while(~scanf(\"%d %d\",&amp;n,&amp;k)){ n&lt;&lt;=k;//相当于 n 乘以 2 的 k 次幂，并将结果赋给 n n&gt;&gt;=k;//相当于 n 除以 2 的 k 次幂，并将结果赋给 n printf(\"%d\\n\",n); } return 0; } 两数交换1234567891011#include &lt;stdio.h&gt; int main(){ int n,m; while(~scanf(\"%d %d\",&amp;n,&amp;m)){ n^=m; m^=n; n^=m; printf(\"%d %d\\n\",n,m); } return 0;} 按位异或 ^ : 不相同 为：1 ; 相同 为 ：0 将参与运算的两操作数各对应的二进制位进行异或操作， 即只有对应的两个二进位不相同时，结果的对应二进制位才是 1，否则为 0。 异或运算的特点是：如果 a^b=c，那么就有 c^b = a 以及 c^a=b 1234567891011121314151617例如：表达式“21 ^ 18 ”的值是7(即二进制数111)。21： 1010118： 1001021^18: 00111假设 n = 5，m = 6 5的二进制为：1016的二进制为：110 n^=m = 5^=6 = 101 ^ 110 = 011 ,此时 n 的二进制为：011 m^=n = 6^=011 = 110 ^ 011 = 101 ,此时 m 的二进制为：101，也正是 5的二进制数，也就是说 m ==开始的 n n^=m = 011^=5 = 011 ^ 101 = 110 ,此时 n 的二进制位：110，也正是 6的二进制数，也就是说 n ==开始的 m 层次结构：A-&gt;B B-&gt;A A-&gt;B 正 反 正 判断 2 的正整数幂1234567891011#include &lt;stdio.h&gt;int main(){ int n; while(~scanf(\"%d\",&amp;n)){ if(!(n &amp; (n-1)) &amp;&amp; n) printf(\"%d 为 2 的正整数幂\\n\",n); else printf(\"%d 不是 2 的正整数幂\\n\",n); } return 0;} 给定整数 n 判断 n 是否为 2 的正整数幂 表达式：(! (n &amp; (n-1)) &amp;&amp; n 1234举个例子： n = 16 = 10000，n-1 = 15 = 1111那么 ：10000 &amp; 01111 = 00000 = 0 再举个例子： n = 256 = 10000000 ,n-1 = 255 = 11111111那么：100000000 &amp; 011111111 = 000000000 = 0 是的，如果一个数 n 是 2 的正整数幂，那么 n 的二进制必定为 1000…. n-1 的二进制必定为 1111…. 即： n &amp; n-1 = 0 所以 (! (n &amp; (n-1)) 为 1 ; &amp;&amp; n ：判断 n 为正数 判断奇偶性1234567891011#include &lt;stdio.h&gt;int main(){ int n; while(~scanf(\"%d\",&amp;n)){ if(n&amp;1) printf(\"%d 是奇数\\n\",n); else printf(\"%d 是偶数\\n\",n); } return 0; } 记住：在做位运算时，位数不够的数，自动在 前面补 0 比如：21 &amp; 1 ：10101 &amp; 00001 = 00001 = 1 16 &amp; 1 ：10000 &amp; 00001 = 00000 = 0 事实证明：偶数的二进制的末尾 为 0，奇数的二进制的末尾 为 1 十进制 m 转换 n 进制方法： m 一直除 n，每相除一次，m 就等于商，直到商为 0，然后余数反排 即可。 123456789101112131415161718192021222324251的二进制：1/2 =0 余1余数反排 即是 1的二进制：1 6的二进制：6/2 =3 余0 3/2 =1 余1 1/2 =0 余1 余数反排 即是 6的二进制：11015的二进制：15/2=7 余1 7/2=3 余1 3/2=1 余1 1/2=0 余1余数反排 即是 15的二进制：1111 5的二进制：5/2 =2 余1 2/2 =1 余0 1/2 =0 余1余数反排 即是 5的二进制：10121的二进制：21/2 =10 余1 10/2 =5 余0 5/2 =2 余1 2/2 =1 余0 1/2 =0 余1余数反排 即是 21的二进制：10101 其他方面 (n &gt;&gt; m) &amp; 1 == (n &gt;&gt; m) | 0 == (n &gt;&gt; m) ^ 0 n &amp; ~(1 &lt;&lt; m) : 将 n 的第 m 位数，重置为 0 n | (1 &lt;&lt; m) : 将 n 的第 m 位数，重置为 1 n ^ (1 &lt;&lt; m) : 将 n 的第 m 位数，取其相反 结束语转载本站文章请注明作者和出处 tomotoes.com，请勿用于任何商业用途。","categories":[{"name":"后端","slug":"后端","permalink":"https://tomotoes.com/blog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://tomotoes.com/blog/tags/%E5%90%8E%E7%AB%AF/"},{"name":"位运算","slug":"位运算","permalink":"https://tomotoes.com/blog/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"让你的 Capslock 键变废为宝","date":"2018-01-18T02:31:08.000Z","path":"/resurrect-your-capslock-key/","text":"很多时候我们是用不到 Capslock 键的。 Capslock 键的劣性&nbsp;&nbsp;&nbsp;&nbsp;如果你是 Windows 系统用户，就会发现，很多时候我们是用不到 Capslock 键的。Capslock 键是切换大小写的锁定，而在平常工作中，只要摁住 Shift 键一样可完成该功能。并且 在键盘的布局上来看 ，Capslock 键 的地理位置 非常便捷，这可不是我们想要的。 &nbsp;&nbsp;&nbsp;&nbsp;下文将告诉你 如何把 作用微小的 Capslock 键 变成你的得力助手。 修改前奏本文使用的修改键的脚本语言 是使用的 AutoHotKey ，一门超级强大的脚本语言。 点击AutoHotKey 官网下载链接下载 AutoHotKey 安装包 并安装。 新建文本文件，文件名格式为 文件名.ahk , 并用编辑器打开，建议 使用下载 AutoHotKey 插件后的 VSCode。 新建完成后的 ahk 文件，你可以双击运行， 或者 右键点击文件，然后单击 Compile Script 转换成 可执行文件再执行。 修改进行曲&nbsp;&nbsp;&nbsp;&nbsp;俗话说：“授人以鱼不如授人以渔”，所以，我先教你三个简单的例子，以便你能快速掌握 所需的 AHK 脚本知识。 模拟发送命令 AHK 文件 模拟键盘事件 AHK 文件 模拟光标行为 AHK 文件 一些 AHK 小常识其中还有一些必备的小知识 AHK 文件 修改成果 AHK 文件 源文件我调试了很长时间的 Capslock 快捷配置，希望能对你有所帮助。 点击显/隐源文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116;管理员运行if not A_IsAdmin{ Run *RunAs \"%A_ScriptFullPath%\" ExitApp};无环境变量#NoEnv;高进程Process Priority,,High;一直关闭 CapslockSetCapsLockState, AlwaysOff; CapsLock -&gt; EscCapsLock::Send {Esc}return; CapsLock &amp; alt -&gt; EnterCapsLock &amp; alt::Send {Enter}return; CapsLock &amp; Space -&gt; ShiftCapsLock &amp; Space::Send {Shift Down}returnCapsLock &amp; Space up::Send {Shift up}return; 光标移动CapsLock &amp; j::MouseMove, -15, 0, 0, R return CapsLock &amp; k:: MouseMove, 0, 15, 0, R return CapsLock &amp; i:: MouseMove, 0, -15, 0, R return CapsLock &amp; l:: MouseMove, 15, 0, 0, R return; 左键单击CapsLock &amp; u:: SendEvent {Blind}{LButton down} KeyWait Enter SendEvent {Blind}{LButton up} return; 右键单击CapsLock &amp; o:: SendEvent {Blind}{RButton down} KeyWait Enter SendEvent {Blind}{RButton up} return; h 向上滚动CapsLock &amp; h::SendEvent {Blind}{WheelUp}return; 分号 向下滚动CapsLock &amp; `;::SendEvent {Blind}{WheelDown}returnCapsLock &amp; 3::SendEvent {Blind}{WheelUp}return CapsLock &amp; 4::SendEvent {Blind}{WheelDown}returnCapsLock &amp; F5::Reloadreturn; 指针移动CapsLock &amp; e::Send {Up}returnCapsLock &amp; d::Send {Down}returnCapsLock &amp; s::Send {Left}returnCapsLock &amp; f::Send {right}return; 行首行尾CapsLock &amp; a::Send {home}returnCapsLock &amp; g::Send {end}return; 左右删除CapsLock &amp; w::Send {BS}returnCapsLock &amp; r::Send {Delete}return; 撤销重做CapsLock &amp; t::Send ^{z}return 结束语转载本站文章请注明作者和出处 tomotoes.com，请勿用于任何商业用途。","categories":[{"name":"开源","slug":"开源","permalink":"https://tomotoes.com/blog/categories/%E5%BC%80%E6%BA%90/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"开源","slug":"开源","permalink":"https://tomotoes.com/blog/tags/%E5%BC%80%E6%BA%90/"},{"name":"AHK","slug":"AHK","permalink":"https://tomotoes.com/blog/tags/AHK/"}]},{"title":"学习 Less-看这篇就够了","date":"2017-12-08T02:52:11.000Z","path":"/learning-less-seeing-this-is-enough/","text":"Less 一门简单而又优雅的预处理语言。 前言CSS 的短板&nbsp;&nbsp;&nbsp;&nbsp;作为前端学习者的我们 或多或少都要学些 CSS ，它作为前端开发的三大基石之一，时刻引领着 Web 的发展潮向。 而 CSS 作为一门标记性语言，可能 给初学者第一印象 就是简单易懂，毫无逻辑，不像编程该有的样子。在语法更新时，每当新属性提出，浏览器的兼容又会马上变成绊脚石，可以说 CSS 短板不容忽视。 &nbsp;&nbsp;&nbsp;&nbsp;问题的诞生往往伴随着技术的兴起， 在 Web 发展的这几年， 为了让 CSS 富有逻辑性，短板不那么严重，涌现出了 一些神奇的预处理语言。 它们让 CSS 彻底变成一门 可以使用 变量 、循环 、继承 、自定义方法等多种特性的标记语言，逻辑性得以大大增强。 预处理语言的诞生其中 就我所知的有三门语言：Sass、Less 、Stylus 。 Sass 诞生于 2007 年，Ruby 编写，其语法功能都十分全面，可以说 它完全把 CSS 变成了一门编程语言。另外 在国内外都很受欢迎，并且它的项目团队很是强大 ，是一款十分优秀的预处理语言。 Stylus 诞生于 2010 年，来自 Node.js 社区，语法功能也和 Sass 不相伯仲，是一门十分独特的创新型语言。 Less 诞生于 2009 年，受 Sass 的影响创建的一个开源项目。 它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充（引用于官网）。 选择预处理语言这是一个十分纠结的问题。 在我看来，这就好比 找女朋友，有人喜欢 贤惠安静的，就有人喜欢 活泼爱闹的，各有各的爱好，可晚上闭灯后 其实都差不多，所以你不用太过纠结。当然了 ，首先 你要有女朋友。 在网上讨论看来，Sass 与 Stylus 相比于 Less 功能更为丰富，但对于学习成本以及适应时间 ，Less 稍胜一筹，这也是我选择 Less 的原因。 Less 没有去掉任何 CSS 的功能，而是在现有的语法上，增添了许多额外的功能特性，所以学习 Less 是一件非常舒服的事情。 如果你之前没有接触过预处理语言，纠结应该学哪一个，不如先看看 下面 Less 的介绍，我相信你会爱上它的。 使用 Less 的前奏使用 Less 有两种方式 在页面中 引入 Less.js 可在官网下载 或使用 CDN1&lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/less.js/2.7.2/less.min.js\"&gt;&lt;/script&gt; 需要注意的是，link 标签一定要在 Less.js 之前引入，并且 link 标签的 rel 属性要设置为 stylesheet/less。12&lt;link rel=\"stylesheet/less\" href=\"style.less\"&gt;&lt;script src=\"less.min.js\"&gt;&lt;/script&gt; 在命令行 使用 npm 安装 1npm install -g less 具体使用命令 1$ lessc styles.less &gt; styles.css 假如还有问题，官网已经有了明确的步骤。 如果你也是 Webpack 的使用者，还需要配合 less-loader 进行处理，具体可见我的这篇文章：Webpack 飞行手册，里面详细说明了 less 的处理方式。 如果你在本地环境，可以使用第一种方式，非常简单；但在生产环境中，性能非常重要，最好使用第二种方式。 正文下面我将简介 Less 的功能特性。 变量我们常常在 CSS 中 看到同一个值重复多次，这样难易于代码维护。 理想状态，应是下面这样： 1234const bgColor=\"skyblue\";$(\".post-content\").css(\"background-color\",bgColor);$(\"#wrap\").css(\"background-color\",bgColor);$(\".arctive\").css(\"background-color\",bgColor); 只要我们修改 bgColor这一个变量， 整个页面的背景颜色都会随之改变。 而 Less 中的变量十分强大，可化万物，值得一提的是，其变量是常量 ，所以只能定义一次，不能重复使用。 值变量 12345678910111213141516/* Less */@color: #999;@bgColor: skyblue;//不要添加引号@width: 50%;#wrap { color: @color; background: @bgColor; width: @width;}/* 生成后的 CSS */#wrap { color: #999; background: skyblue; width: 50%;} 以 @ 开头 定义变量，并且使用时 直接 键入 @名称。 在平时工作中，我们就可以把 常用的变量 封装到一个文件中，这样利于代码组织维护。 1234567@lightPrimaryColor: #c5cae9;@textPrimaryColor: #fff;@accentColor: rgb(99, 137, 185);@primaryTextColor: #646464;@secondaryTextColor: #000;@dividerColor: #b6b6b6;@borderColor: #dadada; 选择器变量 让 选择器 变成 动态 12345678910111213141516171819202122232425/* Less */@mySelector: #wrap;@Wrap: wrap;@{mySelector}{ //变量名 必须使用大括号包裹 color: #999; width: 50%;}.@{Wrap}{ color:#ccc;}#@{Wrap}{ color:#666;}/* 生成的 CSS */#wrap{ color: #999; width: 50%;}.wrap{ color:#ccc;}#wrap{ color:#666;} 属性变量 可减少代码书写量 1234567891011/* Less */@borderStyle: border-style;@Soild:solid;#wrap{ @{borderStyle}: @Soild;//变量名 必须使用大括号包裹}/* 生成的 CSS */#wrap{ border-style:solid;} url 变量 项目结构改变时，修改其变量即可。 12345678910/* Less */@images: \"../img\";//需要加引号body { background: url(\"@{images}/dog.png\");//变量名 必须使用大括号包裹}/* 生成的 CSS */body { background: url(\"../img/dog.png\");} 声明变量 有点类似于 下面的 混合方法 结构: @name: { 属性: 值 ;}; 使用：@name(); 1234567891011121314151617181920212223/* Less */@background: {background:red;};#main{ @background();}@Rules:{ width: 200px; height: 200px; border: solid 1px red;};#con{ @Rules();}/* 生成的 CSS */#main{ background:red;}#con{ width: 200px; height: 200px; border: solid 1px red;} 变量运算 不得不提的是，Less 的变量运算完全超出我的期望，十分强大。 加减法时 以第一个数据的单位为基准 乘除法时 注意单位一定要统一 12345678910111213141516171819/* Less */@width:300px;@color:#222;#wrap{ width:@width-20; height:@width-20*5; margin:(@width-20)*5; color:@color*2; background-color:@color + #111;}/* 生成的 CSS */#wrap{ width:280px; height:200px; margin:1400px; color:#444; background-color:#333;} 变量作用域 一句话理解就是：就近原则，不要跟我提闭包。 借助官网的 Demo 123456789101112/* Less */@var: @a;@a: 100%;#wrap { width: @var; @a: 9%;}/* 生成的 CSS */#wrap { width: 9%;} 用变量去定义变量 12345678910/* Less */@fnord: \"I am fnord.\";@var: \"fnord\";#wrap::after{ content: @@var; //将@var 替换为其值 content:@fnord;}/* 生成的 CSS */#wrap::after{ content: \"I am fnord.\";} 嵌套 &amp; 的妙用 &amp; ：代表的上一层选择器的名字，此例便是header。 12345678910111213141516171819202122/* Less */#header{ &amp;:after{ content:\"Less is more!\"; } .title{ font-weight:bold; } &amp;_content{//理解方式：直接把 &amp; 替换成 #header margin:20px; }}/* 生成的 CSS */#header::after{ content:\"Less is more!\";}#header .title{ //嵌套了 font-weight:bold;}#header_content{//没有嵌套！ margin:20px;} 媒体查询 在以往的工作中，我们使用 媒体查询，都要把一个元素 分开写 12345678#wrap{ width:500px;}@media screen and (max-width:768px){ #wrap{ width:100px; }} Less 提供了一个十分便捷的方式 123456789101112131415161718192021222324/* Less */#main{ //something... @media screen{ @media (max-width:768px){ width:100px; } } @media tv { width:2000px; }}/* 生成的 CSS */@media screen and (maxwidth:768px){ #main{ width:100px; }}@media tv{ #main{ width:2000px; }} 唯一的缺点就是 每一个元素都会编译出自己 @media 声明，并不会合并。 实战技巧 可以借助 Less 在元素中，去定义自己的私有样式。 12345678910/* Less */#main{ // something.. &amp;.show{ display:block; }}.show{ display:none;} 12const main = document.getElementById(\"main\");main.classList.add(\"show\"); 结果： 123456#main.show{ display:block;}.show{ display:none; //会被覆盖。} 混合方法 无参数方法 方法犹如 声明的集合，使用时 直接键入名称即可。 12345678910111213/* Less */.card { // 等价于 .card() background: #f6f6f6; box-shadow: 0 1px 2px rgba(151, 151, 151, .58);}#wrap{ .card;//等价于.card();}/* 生成的 CSS */#wrap{ background: #f6f6f6; box-shadow: 0 1px 2px rgba(151, 151, 151, .58);} 其中 .card 与 .card() 是等价的。 个人建议，为了避免 代码混淆，应写成 : 123456.card(){ //something...}#wrap{ .card();} 要点： . 与 # 皆可作为 方法前缀。 方法后写不写 () 看个人习惯。 默认参数方法 Less 可以使用默认参数，如果 没有传参数，那么将使用默认参数。 @arguments 犹如 JS 中的 arguments 指代的是 全部参数。 传的参数中 必须带着单位。 12345678910111213141516171819202122232425262728/* Less */.border(@a:10px,@b:50px,@c:30px,@color:#000){ border:solid 1px @color; box-shadow: @arguments;//指代的是 全部参数}#main{ .border(0px,5px,30px,red);//必须带着单位}#wrap{ .border(0px);}#content{ .border;//等价于 .border()}/* 生成的 CSS */#main{ border:solid 1px red; box-shadow:0px,5px,30px,red;}#wrap{ border:solid 1px #000; box-shadow: 0px 50px 30px #000;}#content{ border:solid 1px #000; box-shadow: 10px 50px 30px #000;} 方法的匹配模式 与 面向对象中的多态 很相似 123456789101112131415161718192021222324252627/* Less */.triangle(top,@width:20px,@color:#000){ border-color:transparent transparent @color transparent ;}.triangle(right,@width:20px,@color:#000){ border-color:transparent @color transparent transparent ;}.triangle(bottom,@width:20px,@color:#000){ border-color:@color transparent transparent transparent ;}.triangle(left,@width:20px,@color:#000){ border-color:transparent transparent transparent @color;}.triangle(@_,@width:20px,@color:#000){ border-style: solid; border-width: @width;}#main{ .triangle(left, 50px, #999)}/* 生成的 CSS */#main{ border-color:transparent transparent transparent #999; border-style: solid; border-width: 50px;} 要点 第一个参数 left 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。 如果匹配的参数 是变量，则将会匹配，如 @_ 。 方法的命名空间 让方法更加规范 12345678910111213141516171819202122232425262728293031323334/* Less */#card(){ background: #723232; .d(@w:300px){ width: @w; #a(@h:300px){ height: @h;//可以使用上一层传进来的方法 } }}#wrap{ #card &gt; .d &gt; #a(100px); // 父元素不能加 括号}#main{ #card .d();}#con{ //不得单独使用命名空间的方法 //.d() 如果前面没有引入命名空间 #card ，将会报错 #card; // 等价于 #card(); .d(20px); //必须先引入 #card}/* 生成的 CSS */#wrap{ height:100px;}#main{ width:300px;}#con{ width:20px;} 要点 在 CSS 中&gt; 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。 在引入命令空间时，如使用 &gt; 选择器，父元素不能加 括号。 不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。 子方法 可以使用上一层传进来的方法 方法的条件筛选 Less 没有 if else，可是它有 when 1234567891011121314151617181920212223242526272829/* Less */#card{ // and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行 .border(@width,@color,@style) when (@width&gt;100px) and(@color=#999){ border:@style @color @width; } // not 运算符，相当于 非运算 !，条件为 不符合才会执行 .background(@color) when not (@color&gt;=#222){ background:@color; } // , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行 .font(@size:20px) when (@size&gt;50px) , (@size&lt;100px){ font-size: @size; }}#main{ #card&gt;.border(200px,#999,solid); #card .background(#111); #card &gt; .font(40px);}/* 生成后的 CSS */#main{ border:solid #999 200px; background:#111; font-size:40px;} 要点 比较运算有： &gt; &gt;= = =&lt; &lt;。 = 代表的是等于 除去关键字 true 以外的值都被视为 false： 数量不定的参数 如果你希望你的方法接受数量不定的参数，你可以使用… ，犹如 ES6 的扩展运算符。 1234567891011121314151617/* Less */.boxShadow(...){ box-shadow: @arguments;}.textShadow(@a,...){ text-shadow: @arguments;}#main{ .boxShadow(1px,4px,30px,red); .textShadow(1px,4px,30px,red);}/* 生成后的 CSS */#main{ box-shadow: 1px 4px 30px red; text-shadow: 1px 4px 30px red;} 方法使用 important！ 使用方法 非常简单，在方法名后 加上关键字即可。 12345678910111213/* Less */.border{ border: solid 1px red; margin: 50px;}#main{ .border() !important;}/* 生成后的 CSS */#main { border: solid 1px red !important; margin: 50px !important;} 循环方法 Less 并没有提供 for 循环功能，但这也难不倒 聪明的程序员，使用递归去实现。 下面是官网中的一个 Demo，模拟了生成栅格系统。 12345678910111213141516171819202122/* Less */.generate-columns(4);.generate-columns(@n, @i: 1) when (@i =&lt; @n) { .column-@{i} { width: (@i * 100% / @n); } .generate-columns(@n, (@i + 1));}/* 生成后的 CSS */.column-1 { width: 25%;}.column-2 { width: 50%;}.column-3 { width: 75%;}.column-4 { width: 100%;} 属性拼接方法 +_ 代表的是 空格；+ 代表的是 逗号。 逗号123456789101112/* Less */.boxShadow() { box-shadow+: inset 0 0 10px #555;}.main { .boxShadow(); box-shadow+: 0 0 20px black;}/* 生成后的 CSS */.main { box-shadow: inset 0 0 10px #555, 0 0 20px black;} 空格12345678910111213/* Less */.Animation() { transform+_: scale(2);}.main { .Animation(); transform+_: rotate(15deg);}/* 生成的 CSS */.main { transform: scale(2) rotate(15deg);} 实战技巧 下面是官网中的一个非常赞的 Demo 1234567891011121314/* Less */.average(@x, @y) { @average: ((@x + @y) / 2);}div { .average(16px, 50px); // 调用 方法 padding: @average; // 使用返回值}/* 生成的 CSS */div { padding: 33px;} 可以说 Less 是一门优雅编程语言。 继承extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。 extend 关键字的使用 123456789101112131415161718192021/* Less */.animation{ transition: all .3s ease-out; .hide{ transform:scale(0); }}#main{ &amp;:extend(.animation);}#con{ &amp;:extend(.animation .hide);}/* 生成后的 CSS */.animation,#main{ transition: all .3s ease-out;}.animation .hide , #con{ transform:scale(0);} all 全局搜索替换 使用选择器匹配到的 全部声明。 123456789101112131415161718/* Less */#main{ width: 200px;}#main { &amp;:after { content:\"Less is good!\"; }}#wrap:extend(#main all) {}/* 生成的 CSS */#main,#wrap{ width: 200px;}#main:after, #wrap:after { content: \"Less is good!\";} 减少代码的重复性 从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明，这无疑 增加了代码的重复性。 方法示例 与上面的 extend 进行对比： 123456789101112131415161718192021222324252627/* Less */.Method{ width: 200px; &amp;:after { content:\"Less is good!\"; }}#main{ .Method;}#wrap{ .Method;}/* 生成的 CSS */#main{ width: 200px; &amp;:after{ content:\"Less is good!\"; } }#wrap{ width: 200px; &amp;:after{ content:\"Less is good!\"; } } 要点 翻译官网 选择器和扩展之间 是允许有空格的：pre:hover :extend(div pre). 可以有多个扩展: pre:hover:extend(div pre):extend(.bucket tr) - 注意这与 pre:hover:extend(div pre, .bucket tr)一样。 这是不可以的，扩展必须在最后 : pre:hover:extend(div pre).nth-child(odd)。 如果一个规则集包含多个选择器，所有选择器都可以使用 extend 关键字。 导入 导入 less 文件 可省略后缀 123import \"main\"; //等价于import \"main.less\"; @import 的位置可随意放置 1234#main{ font-size:15px;}@import \"style\"; reference Less 中 最强大的特性 使用 引入的 Less 文件，但不会 编译它。 1234/* Less */@import (reference) \"bootstrap.less\"; #wrap:extend(.navbar all){} 翻译官网： 使用@import (reference)导入外部文件，但不会添加 把导入的文件 编译到最终输出中，只引用。 once @import 语句的默认行为。这表明相同的文件只会被导入一次，而随后的导入文件的重复代码都不会解析。 12@import (once) \"foo.less\";@import (once) \"foo.less\"; // this statement will be ignored multiple 使用@import (multiple)允许导入多个同名文件。 1234567891011121314151617/* Less */// file: foo.less.a { color: green;}// file: main.less@import (multiple) \"foo.less\";@import (multiple) \"foo.less\";/* 生成后的 CSS */.a { color: green;}.a { color: green;} 函数 判断类型 isnumber 判断给定的值 是否 是一个数字。 12345678isnumber(#ff0); // falseisnumber(blue); // falseisnumber(\"string\"); // falseisnumber(1234); // trueisnumber(56px); // trueisnumber(7.8%); // trueisnumber(keyword); // falseisnumber(url(...)); // false iscolor 判断给定的值 是否 是一个颜色。 isurl 判断给定的值 是否 是一个 url 。 颜色操作 saturate 增加一定数值的颜色饱和度。 lighten 增加一定数值的颜色亮度。 darken 降低一定数值的颜色亮度。 fade 给颜色设定一定数值的透明度。 mix 根据比例混合两种颜色。 数学函数 ceil 向上取整。 floor 向下取整。 percentage 将浮点数转换为百分比字符串。 round 四舍五入。 sqrt 计算一个数的平方根。 abs 计算数字的绝对值，原样保持单位。 pow 计算一个数的乘方。 由于 文章 篇幅有限，所以 只能介绍一些 使用效率高的函数。 如果你想了解更多，可以去官网的函数链接 其他 注释 /* */ CSS 原生注释，会被编译在 CSS 文件中。 /&nbsp;&nbsp;&nbsp;/ Less 提供的一种注释，不会被编译在 CSS 文件中。 避免编译 123456789/* Less */#main{ width:~'calc(300px-30px)';}/* 生成后的 CSS */#main{ width:calc(300px-30px);} 结构： ~' 值 ' 变量拼串 在平时工作中，这种需求 太常见了。 在下面例子中， 实现了不同的 transtion-delay、animation、@keyframes 12345678910111213141516171819.judge(@i) when(@i=1){ @size:15px;}.judge(@i) when(@i&gt;1){ @size:16px;}.loopAnimation(@i) when (@i&lt;16) { .circle:nth-child(@{i}){ .judeg(@i); border-radius:@size @size 0 0; animation: ~\"circle-@{i}\" @duration infinite @ease; transition-delay:~\"@{i}ms\"; } @keyframes ~\"circle-@{i}\" { // do something... } .loopAnimation(@i + 1);} 结构： ~\"字符@{变量}字符\"; 使用 JS 因为 Less 是由 JS 编写，所以 Less 有一得天独厚的特性：代码中使用 Javascript 。 1234567891011121314151617181920212223242526/* Less */@content:`\"aaa\".toUpperCase()`;#randomColor{ @randomColor: ~\"rgb(`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`)\";}#wrap{ width: ~\"`Math.round(Math.random() * 100)`px\"; &amp;:after{ content:@content; } height: ~\"`window.innerHeight`px\"; alert:~\"`alert(1)`\"; #randomColor(); background-color: @randomColor;}/* 生成后的 CSS */// 弹出 1#wrap{ width: 随机值（0~100）px; height: 743px;//由电脑而异 background: 随机颜色;}#wrap::after{ content:\"AAA\";} &nbsp;&nbsp;&nbsp;&nbsp;前几个月 ， 有个 CSS in JS 的概念非常火，现在 看来 JS in CSS 也未曾不可。我觉得完全可以根据 Less 这个特性来造个轮子，JS 来控制 CSS ，形成 动态属性，如果成功 很可能会改变 现在前端的打开姿势。 &nbsp;&nbsp;&nbsp;&nbsp;从我学习 Web 以来，无数前辈告诉我，Web 有三大基石，JS 控制行为，HTML 控制结构，CSS 控制样式。我一直再想 为什么要分为 3 个语言？为什么不能合成一个语言？或者说 就没有更合适的吗？在这几年的 Web 发展中，页面从 MVC 到 现在的 MVVC，结构正在发生着改变，但 其根本 不过是造了一个又一个 完美的轮子。我们为什么就不能打破传统呢？让 前端的 三大基石 变成一座大山呢？ &nbsp;&nbsp;&nbsp;&nbsp;请试想一下，那该是个怎样的世界。 结束语以上便是 Less 的特性总结，希望本文能对你有所帮助。 转载本站文章请注明作者和出处 tomotoes.com，请勿用于任何商业用途。 .post-content ol li > p:nth-child(1){font-weight:bold;color:#555;text-shadow: rgb(207, 207, 207) 0 0 1px;}","categories":[{"name":"前端","slug":"前端","permalink":"https://tomotoes.com/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomotoes.com/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Less","slug":"Less","permalink":"https://tomotoes.com/blog/tags/Less/"}]},{"title":"VSCode 之高效快捷键","date":"2017-12-05T08:40:11.000Z","path":"/vscode-efficient-shortcuts/","text":"绝对福利,不容错过！ 前言常言道：“工欲善其事必先利其器”，而我的器便是 VSCode ，这是一款高颜值的编辑器。 不过在经过长时间的使用后，发现总有些一些快捷键令我难以接受。 遂花了一天的时间，将快捷键全部调整了一遍，总结如下： 😶 底部有源文件,可供你替换 正文编辑 Alt + Enter 跳转到下一个编辑点 Ctrl + A 全选 Ctrl + Shift + A Autoprefixer/Eslint Ctrl + Shift + Z 重做 Ctrl + R 注释当前行 Ctrl + T 格式化 Ctrl + Y 选择下一个匹配 Ctrl + Shift + Y 选择所有匹配项 Ctrl + / 增加注释 Ctrl + J 连接下一行 Ctrl + Shift + J 将标签内的内容全部缩成一行 Ctrl + P 交换字符位置 Ctrl + G 浏览 markdown 开启 LiveServer Alt + G 关闭 LiveServer Alt + .Emmet 命令列表 Alt + z 自动换行 Ctrl + L 选中一行 Ctrl + Shift + L 跳转行 Ctrl + D 删除行 Ctrl + F 搜索 Ctrl + H 替换 Ctrl + Shift + C 向下复制一行 Ctrl + Shift + V 打开 Ditto Ctrl + Enter 在当前行下边插入一行 Shift + Enter 在当前行上方插入一行 Alt + Up/Down 移动行 Ctrl + Shift + [] 折叠代码 Alt + X 光标撤销 Ctrl + F5 Code Run Ctrl + Shift + Space 显示参数 Ctrl + 左键 多处编辑 Ctrl + Shift + 左键 块选择 Alt + Shift + Right 选中标签内中的内容 Alt + Shift + Left 选中标签中的第一个子标签 Alt + Left 移除包裹标签 Alt + Right 键入标签名 包围所在标签 与 多光标一起使用 威力无穷 Alt + Shift +Enter 将当前标签替换成键入的标签 Ctrl + Shift + J 将标签内的内容全部缩成一行 Alt + Enter 跳转到下一个编辑点 F12 移动到定义处 Alt + F12 定义处缩略图,可更改 Shift + F12 列出所有的引用 Ctrl + Alt + Up 定位到文件中上一个修改 Ctrl + Alt + Down 定位到文件中下一个修改 命令窗口 F1 Ctrl + Shift + P Ctrl + E 输入 &gt; Ctrl + P 输入 &gt; 其中在 Ctrl + E / P 窗口中还可以这么玩 : 直接输入文件名，跳转到文件 ? 列出当前可执行的动作 ! 显示 Errors 或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 # 根据名字查找 symbol 项目 Ctrl + O 打开文件 Ctrl + Shift + O 打开文件夹 Ctrl + Alt + O 打开本地 Git 项目 Ctrl + B 打开最近项目 Alt + R (需先 Ctrl + Shift + E) 打开聚焦文件的路径 标签 Ctrl + Shift + T 打开关闭后的标签 Ctrl + Num 聚焦到某个标签 Ctrl + W 关闭当前标签 调试 F5 调试 Shift + F5 运行 不调试 F10 单步执行 注意事项 先关掉所有的 Chrome 启动调试 Launch to Chrome 可以使用断点，单独调试 还可以像 Chrome 调试台那样 去使用调试12345678910111213141516171819202122232425262728293031$(\"#header\").style.background获取 header 的背景颜色$ document.querySelector 。 $$相当于 document.querySelectorAll 。 $_ 返回上一个表达式的值 dirconsole.dir keys取对象的键名, 返回键名组成的数组 values(object)返回一个数组，该数组包含属于指定对象的所有属性值。dirxml(object)$(\"#header\").css(\"color\",\"red\");使用页面中的框架,记录 jQuery1 + 2普通输入 function(){alert(1);}函数 设置 Ctrl + , 设置 Ctrl + Shift + , 快捷键 Ctrl + Alt + , 代码片段 Alt + F2 选择主题 Alt + F1 改变语言 Ctrl + Shift + S 设置 窗口 Ctrl + M 打开新窗口 Ctrl + Shift +M 重新载入 Ctrl + \\ 多栏编辑 Ctrl + Shift + \\ 切换多栏布局 Alt + W 只保留当前栏 Alt + A 当前栏增大视图 Alt + Num 聚焦到第 Num 个栏 Booksmarks Ctrl + Q 切换书签 Ctrl + Shift + Q 跳转到下一个书签 Ctrl + Alt + Q 跳转到上一个书签 Ctrl + Shift + Alt + Q 书签列表 F1 + Clear remove all bookmarks in the current file 清除当前文件的所有标签 F1 + Clear from All Files remove all bookmarks from all files 清除所有标签 文件 Ctrl + S 保存当前文件 Ctrl + Shift +S 保存所有文件 Ctrl + Alt + S 另存为 Ctrl + Shift + N 在资源管理器中新建文件 侧边栏 Ctrl + Shift + E 聚焦到资源管理器 Ctrl + Shift + F 全局搜索 Ctrl + Shift + D 调试代码 Ctrl + Shift + G Git 版本库 Ctrl + Shift + X 插件商场 Ctrl + Shift + B 切换侧边栏 Ctrl + Shift + H 全局替换 底栏 Ctrl + Shift + W 问题 F8 下一个错误/警告 Shift + F8 上一个错误/警告 Ctrl + Shift + R 调试控制台 Ctrl + Shift + U 输出 Alt + Q 终端 Markdown Alt + B 粗体 Ctrl + i 斜体 Ctrl + Shift + [/] 增加标题等级 Ctrl + G 浏览视图 右键 Markdown 视图 保存多种类型 其他特性 悬停提示 文件拖拽移动 双击变量 高亮匹配相同词 code ./ 使用 VSCode 打开当前文件 F11 全屏 文件右键 在资源管理器中打开 在终端打开 选择以比较 然后在选择一个文件 即可进行比较 复制路径 Alt + Shift+C Git 查看该文件的历史 Git F1 View Git History (git log) (git.viewHistory) View File History (git.viewFileHistory) View Line History (git.viewLineHistory) Alt + F3 查看文件更改 NPM &amp;&amp; Task Ctrl + I 导入模块 Alt + F5 运行脚本 Ctrl+u 运行任务 源文件点击显/隐源文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713[{ \"key\": \"tab\", \"command\": \"editor.emmet.action.expandAbbreviation\", \"when\": \"config.emmet.triggerExpansionOnTab &amp;&amp; editorTextFocus &amp;&amp; !editorHasMultipleSelections &amp;&amp; !editorHasSelection &amp;&amp; !editorReadonly &amp;&amp; !editorTabMovesFocus\" }, { \"key\": \"ctrl+c\", \"command\": \"-extension.vim_ctrl+c\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.overrideCtrlC &amp;&amp; vim.use&lt;C-c&gt; &amp;&amp; !inDebugRepl\" }, { \"key\": \"ctrl+f\", \"command\": \"-extension.vim_ctrl+f\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-f&gt; &amp;&amp; !inDebugRepl\" }, { \"key\": \"ctrl+l\", \"command\": \"expandLineSelection\", \"when\": \"editorTextFocus\" },{ \"key\": \"ctrl+h\", \"command\": \"-extension.vim_ctrl+h\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-h&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode == 'Insert'\" }, { \"key\": \"ctrl+v\", \"command\": \"-extension.vim_ctrl+v\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-v&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\" }, { \"key\": \"ctrl+f1\", \"command\": \"-extension.viewInBrowser\", \"when\": \"editorTextFocus\" }, { \"key\": \"alt+x\", \"command\": \"cursorUndo\", \"when\": \"editorTextFocus\" },{ \"key\": \"shift+alt+f\", \"command\": \"-editor.action.formatDocument\", \"when\": \"editorHasDocumentFormattingProvider &amp;&amp; editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+f\", \"command\": \"actions.find\" }, { \"key\": \"ctrl+f\", \"command\": \"-actions.find\" }, { \"key\": \"ctrl+shift+f\", \"command\": \"workbench.action.findInFiles\", \"when\": \"!searchInputBoxFocus\" }, { \"key\": \"ctrl+shift+f\", \"command\": \"-workbench.action.findInFiles\", \"when\": \"!searchInputBoxFocus\" }, { \"key\": \"ctrl+shift+f\", \"command\": \"workbench.view.search\", \"when\": \"!searchViewletVisible\" }, { \"key\": \"ctrl+shift+f\", \"command\": \"-workbench.view.search\", \"when\": \"!searchViewletVisible\" }, { \"key\": \"ctrl+r\", \"command\": \"editor.action.commentLine\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+oem_2\", \"command\": \"-editor.action.commentLine\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+d\", \"command\": \"editor.action.deleteLines\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+shift+k\", \"command\": \"-editor.action.deleteLines\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+alt+o\", \"command\": \"-extension.openWith\", \"when\": \"editorTextFocus &amp;&amp; editorLangId == 'html'\" }, { \"key\": \"alt+f1\", \"command\": \"workbench.action.editor.changeLanguageMode\" }, { \"key\": \"ctrl+k m\", \"command\": \"-workbench.action.editor.changeLanguageMode\" }, { \"key\": \"shift+enter\", \"command\": \"editor.action.insertLineBefore\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+shift+enter\", \"command\": \"-editor.action.insertLineBefore\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"ctrl+shift+g\", \"command\": \"workbench.view.scm\" }, { \"key\": \"ctrl+shift+g\", \"command\": \"-workbench.view.scm\" }, { \"key\": \"alt+shift+g\", \"command\": \"markdown.showPreview\", \"when\": \"editorLangId == 'markdown'\" }, { \"key\": \"ctrl+shift+v\", \"command\": \"-markdown.showPreview\", \"when\": \"editorLangId == 'markdown'\" }, { \"key\": \"ctrl+shift+c\", \"command\": \"editor.action.copyLinesDownAction\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"shift+alt+down\", \"command\": \"-editor.action.copyLinesDownAction\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" }, { \"key\": \"alt+r\", \"command\": \"revealFileInOS\", \"when\": \"explorerViewletFocus &amp;&amp; explorerViewletVisible\" }, { \"key\": \"shift+alt+r\", \"command\": \"-revealFileInOS\", \"when\": \"explorerViewletFocus &amp;&amp; explorerViewletVisible\" }, { \"key\": \"ctrl+a\", \"command\": \"-extension.vim_ctrl+a\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-a&gt; &amp;&amp; !inDebugRepl\" }, { \"key\": \"ctrl+g\", \"command\": \"extension.liveServer.goOnline\", \"when\": \"editorTextFocus &amp;&amp; editorLangId != 'markdown'\" }, { \"key\": \"alt+g\", \"command\": \"extension.liveServer.goOffline\", \"when\": \"editorTextFocus &amp;&amp; editorLangId != 'markdown'\" }, { \"key\": \"alt+l o\", \"command\": \"-extension.liveServer.goOnline\", \"when\": \"editorTextFocus\" }, { \"key\": \"alt+l c\", \"command\": \"-extension.liveServer.goOffline\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+q\", \"command\": \"bookmarks.toggle\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+alt+k\", \"command\": \"-bookmarks.toggle\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+shift+q\", \"command\": \"bookmarks.jumpToNext\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+alt+l\", \"command\": \"-bookmarks.jumpToNext\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+alt+q\", \"command\": \"bookmarks.jumpToPrevious\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+alt+j\", \"command\": \"-bookmarks.jumpToPrevious\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+shift+alt+q\", \"command\": \"bookmarks.listFromAllFiles\" }, { \"key\": \"ctrl+n\", \"command\": \"-extension.vim_ctrl+n\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-n&gt; &amp;&amp; !inDebugRepl\" }, { \"key\": \"ctrl+shift+n\", \"command\": \"explorer.newFile\", }, { \"key\": \"ctrl+n\", \"command\": \"workbench.action.files.newUntitledFile\" , },{ \"key\": \"ctrl+w\", \"command\": \"-extension.vim_ctrl+w\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-w&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+w ctrl+w\", \"command\": \"-extension.vim_navigateGroups\", \"when\": \"vim.active &amp;&amp; vim.use&lt;C-w&gt; &amp;&amp; !editorTextFocus\"},{ \"key\": \"ctrl+w l\", \"command\": \"-extension.vim_navigateRight\", \"when\": \"vim.active &amp;&amp; vim.use&lt;C-w&gt; &amp;&amp; !editorTextFocus\"},{ \"key\": \"ctrl+w j\", \"command\": \"-extension.vim_navigateDown\", \"when\": \"vim.active &amp;&amp; vim.use&lt;C-w&gt; &amp;&amp; !editorTextFocus\"},{ \"key\": \"ctrl+w k\", \"command\": \"-extension.vim_navigateUp\", \"when\": \"vim.active &amp;&amp; vim.use&lt;C-w&gt; &amp;&amp; !editorTextFocus\"},{ \"key\": \"ctrl+w h\", \"command\": \"-extension.vim_navigateLeft\", \"when\": \"vim.active &amp;&amp; vim.use&lt;C-w&gt; &amp;&amp; !editorTextFocus\"},{ \"key\": \"ctrl+u\", \"command\": \"-extension.vim_ctrl+u\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-u&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+o\", \"command\": \"-extension.vim_ctrl+o\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-o&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"win+a\", \"command\": \"-extension.vim_cmd+a\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-a&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"backspace\", \"command\": \"-extension.vim_backspace\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+alt+down\", \"command\": \"workbench.action.editor.nextChange\", \"when\": \"editorTextFocus\" },{ \"key\": \"ctrl+alt+up\", \"command\": \"workbench.action.editor.previousChange\", \"when\": \"editorTextFocus\" },{ \"key\": \"win+d\", \"command\": \"-extension.vim_cmd+d\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-d&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"win+right\", \"command\": \"-extension.vim_cmd+right\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-right&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"win+v\", \"command\": \"-extension.vim_cmd+v\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-v&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode == 'SearchInProgressMode'\"},{ \"key\": \"ctrl+pagedown\", \"command\": \"-extension.vim_ctrl+pagedown\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-pagedown&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+r\", \"command\": \"-extension.vim_ctrl+r\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-r&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+pageup\", \"command\": \"-extension.vim_ctrl+pageup\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-pageup&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+shift+2\", \"command\": \"-extension.vim_ctrl+shift+2\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-shift+2&gt;\"},{ \"key\": \"ctrl+x\", \"command\": \"-extension.vim_ctrl+x\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-x&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+x\", \"command\": \"-extension.vim_ctrl+x\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-x&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+x\", \"command\": \"-extension.vim_ctrl+x\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-x&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"-extension.vim_ctrl+y\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-y&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"delete\", \"command\": \"-extension.vim_delete\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"delete\", \"command\": \"-extension.vim_delete\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"end\", \"command\": \"-extension.vim_end\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"end\", \"command\": \"-extension.vim_end\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"home\", \"command\": \"-extension.vim_home\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"win+left\", \"command\": \"-extension.vim_cmd+left\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;D-left&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"ctrl+oem_4\", \"command\": \"-extension.vim_ctrl+[\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-[&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+ oem_6\", \"command\": \"-extension.vim_ctrl+]\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-]&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+b\", \"command\": \"-extension.vim_ctrl+b\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-b&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"ctrl+d\", \"command\": \"-extension.vim_ctrl+d\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+e\", \"command\": \"-extension.vim_ctrl+e\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-e&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+i\", \"command\": \"-extension.vim_ctrl+i\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-i&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+j\", \"command\": \"-extension.vim_ctrl+j\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-j&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"ctrl+k\", \"command\": \"-extension.vim_ctrl+k\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-k&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"ctrl+p\", \"command\": \"-extension.vim_ctrl+p\", \"when\": \"suggestWidgetVisible &amp;&amp; vim.active &amp;&amp; vim.use&lt;C-p&gt;\"},{ \"key\": \"down\", \"command\": \"-extension.vim_down\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; !suggestWidgetMultipleSuggestions &amp;&amp; !suggestWidgetVisible\"},{ \"key\": \"left\", \"command\": \"-extension.vim_left\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl\"},{ \"key\": \"right\", \"command\": \"-extension.vim_right\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl\"},{ \"key\": \"shift+backspace\", \"command\": \"-extension.vim_shift+backspace\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.use&lt;shift+BS&gt; &amp;&amp; !inDebugRepl &amp;&amp; vim.mode == 'SearchInProgressMode'\"},{ \"key\": \"tab\", \"command\": \"-extension.vim_tab\", \"when\": \"editorFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; vim.mode != 'Insert'\"},{ \"key\": \"up\", \"command\": \"-extension.vim_up\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; !inDebugRepl &amp;&amp; !suggestWidgetMultipleSuggestions &amp;&amp; !suggestWidgetVisible\"},{ \"key\": \"win+c\", \"command\": \"-extension.vim_cmd+c\", \"when\": \"editorTextFocus &amp;&amp; vim.active &amp;&amp; vim.overrideCopy &amp;&amp; vim.use&lt;D-c&gt; &amp;&amp; !inDebugRepl\"},{ \"key\": \"ctrl+y\", \"command\": \"editor.action.addSelectionToNextFindMatch\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+shift+o\", \"command\": \"workbench.action.files.openFolder\"},{ \"key\": \"ctrl+/\", \"command\": \"editor.action.blockComment\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\"},{ \"key\": \"ctrl+shift+s\", \"command\": \"workbench.action.files.saveAll\"},{ \"key\": \"ctrl+alt+s\", \"command\": \"workbench.action.files.saveAs\"},{ \"key\": \"ctrl+shift+y\", \"command\": \"editor.action.changeAll\", \"when\": \"editorTextFocus &amp;&amp; !editorReadonly\" },{ \"key\": \"ctrl+t\", \"command\": \"editor.action.formatDocument\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+shift+t\", \"command\": \"HookyQR.beautifyFile\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+j\", \"command\": \"editor.action.joinLines\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+m\", \"command\": \"editor.action.insertSnippet\", \"when\": \"editorFocus\"},{ \"key\": \"alt+enter\", \"command\": \"editor.action.inspectTMScopes\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+p\", \"command\": \"editor.action.transposeLetters\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+shift+a\", \"command\": \"eslint.executeAutofix\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+alt+,\", \"command\": \"workbench.action.openSnippets\", \"when\": \"editorFocus\"},{ \"key\": \"alt+f2\", \"command\": \"workbench.action.selectTheme\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+m\", \"command\": \"workbench.action.newWindow\" },{ \"key\": \"ctrl+shift+,\", \"command\": \"workbench.action.openGlobalKeybindings\" },{ \"key\": \"ctrl+u\", \"command\": \"workbench.action.tasks.runTask\" },{ \"key\": \"f11\", \"command\": \"workbench.action.toggleZenMode\" },{ \"key\": \"ctrl+f5\", \"command\": \"code-runner.run\" },{ \"key\": \"ctrl+i\", \"command\": \"npm-intellisense.import\" , \"when\": \"editorLangId != 'markdown'\"},{ \"key\": \"alt+f5\", \"command\": \"npm-script.run\" },{ \"key\": \"shift+f5\", \"command\": \"workbench.action.debug.run\", \"when\": \"!inDebugMode\" },{ \"key\": \"ctrl+shift+\\\\\", \"command\": \"workbench.action.toggleEditorGroupLayout\" },{ \"key\": \"ctrl+shift+b\", \"command\": \"workbench.action.toggleSidebarVisibility\" },{ \"key\": \"ctrl+g\", \"command\": \"markdown.showPreview\", \"when\": \"editorLangId == 'markdown'\"},{ \"key\": \"ctrl+shift+l\", \"command\": \"workbench.action.gotoLine\" },{ \"key\": \"alt+a\", \"command\": \"workbench.action.increaseViewSize\" , \"when\": \"editorLangId != 'markdown'&amp;&amp;editorFocus\"},{ \"key\": \"alt+w\", \"command\": \"workbench.action.joinTwoGroups\" , \"when\": \"editorFocus\"},{ \"key\": \"ctrl+1\", \"command\": \"workbench.action.openEditorAtIndex1\" },{ \"key\": \"ctrl+2\", \"command\": \"workbench.action.openEditorAtIndex2\" },{ \"key\": \"ctrl+3\", \"command\": \"workbench.action.openEditorAtIndex3\" },{ \"key\": \"ctrl+4\", \"command\": \"workbench.action.openEditorAtIndex4\" },{ \"key\": \"ctrl+5\", \"command\": \"workbench.action.openEditorAtIndex5\" },{ \"key\": \"ctrl+6\", \"command\": \"workbench.action.openEditorAtIndex6\" },{ \"key\": \"ctrl+7\", \"command\": \"workbench.action.openEditorAtIndex7\" },{ \"key\": \"ctrl+8\", \"command\": \"workbench.action.openEditorAtIndex8\" },{ \"key\": \"ctrl+9\", \"command\": \"workbench.action.openEditorAtIndex9\" },{ \"key\": \"alt+1\", \"command\": \"workbench.action.focusFirstEditorGroup\" },{ \"key\": \"alt+2\", \"command\": \"workbench.action.focusSecondEditorGroup\" },{ \"key\": \"alt+3\", \"command\": \"workbench.action.focusThirdEditorGroup\" },{ \"key\": \"ctrl+shift+m\", \"command\": \"workbench.action.reloadWindow\" },{ \"key\": \"alt+.\", \"command\": \"workbench.action.showEmmetCommands\", \"when\": \"editorLangId != 'markdown'&amp;&amp;editorFocus\"},{ \"key\": \"alt+enter\", \"command\": \"editor.emmet.action.nextEditPoint\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+shift+j\", \"command\": \"editor.emmet.action.mergeLines\", \"when\": \"editorFocus\"},{ \"key\": \"alt+left\", \"command\": \"editor.emmet.action.removeTag\", \"when\": \"editorFocus\"},{ \"key\": \"alt+right\", \"command\": \"editor.emmet.action.wrapWithAbbreviation\", \"when\": \"editorFocus\"},{ \"key\": \"alt+shift+right\", \"command\": \"editor.emmet.action.balanceOut\", \"when\": \"editorFocus\"},{ \"key\": \"alt+shift+left\", \"command\": \"editor.emmet.action.balanceIn\", \"when\": \"editorFocus\"},{ \"key\": \"alt+shift+enter\", \"command\": \"editor.emmet.action.updateTag\", \"when\": \"editorFocus\"},{ \"key\": \"ctrl+shift+w\", \"command\": \"workbench.actions.view.problems\" },{ \"key\": \"alt+q\", \"command\": \"workbench.action.terminal.toggleTerminal\" },{ \"key\": \"ctrl+shift+r\", \"command\": \"workbench.debug.action.toggleRepl\" },{ \"key\": \"ctrl+shift+a\", \"command\": \"autoprefixer.execute\", \"when\": \"editorTextFocus &amp;&amp; editorLangId != 'javascript' &amp;&amp; editorLangId != 'typescript'\"},{ \"key\": \"ctrl+shift+a\", \"command\": \"tslint.fixAllProblems\", \"when\": \"editorTextFocus &amp;&amp; editorLangId != 'javascript' &amp;&amp; editorLangId != 'less' &amp;&amp; editorLangId != 'css'\"},{ \"key\": \"ctrl+alt+o\", \"command\": \"gitProjectManager.openProject\" },{ \"key\": \"ctrl+b\", \"command\": \"workbench.action.openRecent\"},{ \"key\": \"ctrl+r\", \"command\": \"-workbench.action.openRecent\"},{ \"key\": \"alt+b\", \"command\": \"markdown.extension.editing.toggleBold\", \"when\": \"editorTextFocus &amp;&amp; editorLangId == 'markdown'\" },{ \"key\": \"alt+c\", \"command\": \"markdown-preview-enhanced.syncPreview\", \"when\": \"editorLangId == 'markdown'\" },{ \"key\": \"win+`\", \"command\": \"search.action.collapseSearchResults\"}] 结束如果你的机器是 Windows 系统，同时也是 VSCode 重度使用者，不妨试试我的快捷键，可以让你的操作彻底飞起来~😎 转载本站文章请注明作者和出处 tomotoes.com，请勿用于任何商业用途。 .Key{color:#999;font-size:98%;}","categories":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"快捷键","slug":"快捷键","permalink":"https://tomotoes.com/blog/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"VSCode","slug":"VSCode","permalink":"https://tomotoes.com/blog/tags/VSCode/"}]},{"title":"Webpack 飞行手册","date":"2017-11-30T11:16:57.000Z","path":"/webpack-flight-manual/","text":"现在是一个 Web 技术蓬发的时代。 前言在学习 Webpack 之前，我们需要了解一个概念：模块。 何为模块？如果你曾学过 Java , C# 之类的语言，一定会知道 Java 中的 import 或 C# 中的 using 吧？ 比如：我想在 C# 中进行数据库操作，我只需要在代码头部加上 下面这两段代码即可。 12using System.Data;using System.Data.SqlClient; 这两段代码可以看成 两个与数据库操作相关的模块。 当我们需求是数据库，或者是读取 IO 等其他操作，我们便加载其他不同的模块。 很明显，这实现了编程中的一个非常重要的功能 按需加载。 在前端中 模块又该如何定义呢？ 按照我个人的理解： 在 HTML 中 模块 便是一个组件123456&lt;div class=\"layer\"&gt; &lt;div&gt;&lt;%= name %&gt;&lt;/div&gt; &lt;% for(var i = 0; i &lt; People.length;++i) { %&gt; &lt;%= People[i] %&gt; &lt;% } %&gt;&lt;/div&gt; 在 CSS 中 模块 便是一个局部样式 123456header{ display:block;}header h1{ font-size: 60px;} 在 Javascript 中 模块 便是一个封装着方法或数据的脚本文件 12let People = { name: \"Simon\" } ;module.exports = People; 而我们又该怎样实现 在前端中加载模块呢？ 下面是两个很常见的例子： 在 Less 中 123@import \"header\";@import \"layout\";@import \"footer\"; 在 Javascript 123456789// CommonJSconst $ = require(\"jQuery\");//es6let People = { name: \"Simon\" } ;module.exports = People;import \"./layer.less\";import tpl from \"./layer.ejs\"; 如果你直接运行以上代码，浏览器并不会解析，这个时候，就要依靠 Webpack 了！ Webpack 是什么Webpack 是一款目前非常流行的前端模块打包工具，可以将项目中所加载的模块进行打包，以及将 一些浏览器不支持的语言进行转换。 Webpack 的打包原理是 先找到入口文件，递归探索出所有依赖的模块，最后 利用 Loader 进行不同文件类型的处理，打包成一个 Javascript 文件。 其中，Webpack 的两个最核心原理分别是： 一切皆模块 按需加载 当然 Webpack 的作用不止加载模块这么简单，前端的常用需求通常都可以实现：利用 Loader 转换 es6 、 Less 、 Typescript ，还可利用插件 开发多页面应用,等等诸多强大功能。 正文下面，我将讲解 Webpack 的具体使用和配置。 安装我一般在项目中使用 Webpack，都是先执行下面这四条命令进行 Webpack 的安装 npm install -g webpack 在全局安装 Webpack，第一次使用时 执行 npm install --save-dev webpack 将 Webpack 安装到你的项目 npm init npm 初始化，会询问你的项目信息，可以回车跳过 npm install --save-dev webpack-dev-server 在当前项目，安装 Webpack 服务器 安装完成后，便是建立配置文件了。 基本配置在项目根目录下新建名为 webpack.config.js 的文件， 基本上 一个配置文件的大体结构就是下面这样： 123456789101112131415161718modules.export={ entry:{ /* 入口文件 */ }, output:{ /* 出口文件 */ }, module:{ /* Loader */ rules:[{},{},{}] }, plugins:[ /* 插件 */ ], devtool: ... devServer: {...} resolve:{...}} 我们下面就先分析 modules.export 各个属性 入口entry 代表是入口文件，Webpack 工作的开始。 Webpack 会递归的探索出 入口文件中所依赖的模块，并按照顺序 利用 Loader 进行处理。 官网给出了其 3 种数据类型： 字符串1entry: \"app.js\"; 数组 数组中的每一项都会被打包，形成互不依赖的文件1entry: [\"app.js\",\"main.js\"]; 对象 对象中的每一个属性都会被打包，形成互不依赖的文件1234entry:{ app: \"./src/js/app.js\", main: \"./src/js/main.js\"} 一般入口文件中多是 import 或者 require 等模块导入命令。 出口output 顾名思义，Webpack 打包后文件的具体配置 常用的属性有 4 个 path: ${__dirname }/dist 打包后文件所在路径 filename: “js/[name].js” 打包后文件的名字，这里有 4 种常用的写法 自定义 [name].js 代表的便是入口的文件名 [hash].js 此次打包后的 hash 值 [chunkhash] 该块打包后的 hash 值 publicPath: \"http://cdn.com/\" 上线时的公共路径，主要应用于线上 chunkFilename: ‘js/[name].js’ 按需加载模块时输出的文件名称 LoaderLoader 是 Webpack 中最振奋人心的东西了！ 将一切浏览器不支持的语言，处理成 浏览器可以支持。 针对各个文件类型，都有各种的 Loader 等你去挖掘。 Loader 的工作方式 是从右向左执行，链式地按照顺序进行编译。 loader 链中的第一个返回值给下一个 loader，在最后一个 loader，返回所预期的结果。 loader 可以是同步或异步函数，也可使用 options 对象去接受配置参数。 基础结构 1234567891011module:{ rules:[ { test:/\\.xxx$/,//以 xxx 结尾的文件 loader: \"xxx-loader\", exclude: {排除的路径}, include: {包含的路径}, options: {Loader 配置} } ]} 可以很清楚的看到，Loader 利用 test 的正则 找到各个类型文件，然后使用 loader 进行处理，便可转换成浏览器支持的文件。 其中我知道的 loader 的写法有两种: 每一个 loader 都是一个对象12345loaders:[ {loader:\"style-loader\"}, { loader: \"css-loader?modules\", options: { importLoaders: 1 } }, {loader: \"less-loader\"}] 使用 ! 号拼接的写法1loader: \"style-loader!css-loader?importLoaders=1!less-loader\" 下面介绍三个 前端必备的 Loader 方式css style-loader 通过注入style标签将 CSS 添加到 DOM 1npm install style-loader --save-dev css-loader css-loader 像 import / require（）一样解释@import 和 url（）并解析它们。1npm install css-loader --save-dev postcss-loader 补充 不兼容的 css 属性 的浏览器前缀1npm install post-loader --save-dev less-loader 将 Less 转换成 CSS12npm install less --save-devnpm install less-loader --save-dev javascriptbabel 主要用于将 es6 转换成 es2015 1npm install --save-dev babel-core babel-loader babel-preset-es2015 图片 &amp; 字体 file-loader 用于压缩文件1npm install --save-dev file-loader url-loader 如果文件下于 规定限制，将会转换成 二进制编码1npm install --save-dev url-loader ejs另外 我想介绍一下 自己常用的 ejs-loader 配置 1npm install --save-dev ejs-loader 1test:/\\.ejs$/ , loader:\"ejs-loader\", 使用 123456&lt;div class=\"layer\"&gt; &lt;div&gt;&lt;%= name %&gt;&lt;/div&gt; &lt;% for(let i = 0; i &lt; Array.length;++i) { %&gt; &lt;%= Array[i] %&gt; &lt;% } %&gt;&lt;/div&gt; 1234567//入口文件import tpl from \"./layer.ejs\";document.body.innerHTML = tpl({ name:\"Simon\", arr:[\"Apple\",\"Xiaomi\"]}); 运行 生成后的页面 ，便会发现 ejs 组件已经被加进去了， 想象一下，我们在平时工作中是否可以把 一个轮播图，或者 排行榜 、评论 当成一个组件呢？ 插件plugins 在日常工作中，我们使用 Loader 处理不同类型的文件，当有某种其他方面的需求时，比如 抽离 CSS 、生成多页面 HTML ，plugins 便派上了用场。 插件的使用，一般都要先 require 出来，然后在 plugins 属性中 进行初始化 123const htmlWebpackPlugin = require(\"html-webpack-plugin\");......plugins: [ new htmlWebpackPlugin({/* options */}) ] 下面将介绍 一些工作中常用的插件 clean-webpack-plugin 主要用于 打包之前 先清空 打包目录下的文件，防止文件混乱。1npm install --save-dev clean-webpack-plugin html-webpack-plugin 主要用于生成 HTML，可以规定 模板 HTML，也可以为 模板传入参数，压缩文件等1npm install --save-dev html-webpack-plugin 这个插件可谓是 前端必备的，它的配置有很多123456789101112131415161718192021222324252627282930313233343536373839404142434445new htmlWebpackPlugin({ //打包后的文件名 filename: \"index.html\", //模板 template: \"index.html\", //为 true 自动生成 script 标签添加到 html 中 //或者写 body/head 标签名 inject: false,//js 的注入标签 //通过&lt;%= htmlWebpackPlugin.options.title %&gt;引用 title: \"参数 title\", //通过&lt;%= htmlWebpackPlugin.options.date %&gt; 引用 date: new Date() //网站的图标 favicon: 'path/to/yourfile.ico' //生成此次打包的 hash //如果文件名中有哈希，便代表有 合理的缓冲 hash: true, //排除的块 excludeChunks: [''], //选中的块 与入口文件相关 chunks: ['app','people'], //压缩 minify:{ removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true, } }), 那么问题来了，我们在模板文件中 又该怎样使用参数呢？ 直接按照 ejs 的语法写入 html 文件即可！1234&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;%= htmlWebpackPlugin.options.date %&gt;&lt;/html&gt; 生成后的模板文件1234&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;Thu Dec 07 2017 10:01:58 GMT+0800 (中国标准时间)&lt;/html&gt; 另外，如果想生成 多页面应用，只需 将上面的配置，多复制几遍即可。123new htmlWebpackPlugin({ filename: \"index1.html\", }new htmlWebpackPlugin({ filename: \"index2.html\", }new htmlWebpackPlugin({ filename: \"index3.html\", } UglifyJsPlugin 主要用于压缩 Javascript 文件1npm i -D uglifyjs-webpack-plugin webpack.ProvidePlugin 自动加载模块，全局使用变量，下面借助 官网的 DEMO12345678new webpack.ProvidePlugin({ $: 'jquery', jQuery: 'jquery'})// in a module$('#item'); // &lt;= 起作用jQuery('#item'); // &lt;= 起作用// $ 自动被设置为 \"jquery\" 输出的内容 open-browser-webpack-plugin 打开服务器后 会自动打开浏览器端口，用起来 很方便 HotModuleReplacementPlugin 热更新插件 常用命令 webpack 最基本的启动 webpack 命令。找到根目录下的 webpack.config.js 文件中的 entry 属性，递归出所有项目中依赖的模块。 webpack -w 监控代码变化，实时进行打包更新 webpack -p 对打包后的文件进行压缩，利用线上发布 webpack -d 提供 SourceMaps，方便调试代码 webpack –colors 输出结果带彩色，可以更详细的查看信息 webpack –profile 输出性能数据，可以看到每一步的耗时 前两个命令使用频率会较大 devtool不知道你现在时候有没有一个想法？ webpack 打包后的文件就一定正确无误吗？ 如果发生错误的话，该怎么办呢？ devtool 属性 便提供了生成 sourcemap 的功能，具体有下面这些选项。 source-map 此选项具有最完备的 source map，但会减慢打包的速度； cheap-module-source-map 生成一个不带列映射的 map eval-source-map 使用 eval 打包源文件模块，生成一个完整的 source map。 cheap-module-eval-source-map 这是最快生成 source map 的方法，生成后的 Source Map 会和打包后的 JavaScript 文件同行显示，但没有列映射，所以慎用 devServer contentBase: “./dist”, 本地服务器所加载的页面所在的目录 historyApiFallback: true, 再找不到文件的时候默认指向 index.html inline: true, 当源文件改变时会自动刷新页面 hot: true, 热加载开启 port:8080 设置默认监听端口 resolve extensions: [“.js”, “.html”, “.css”, “.txt”,”less”,”ejs”,”json”], 自动扩展文件后缀名，意味着我们 require 模块可以省略不写后缀名 alias: { Temp: path.resolve(__dirname, “src/templates/“) } 模块别名定义，直接 require(‘AppStore’) 即可,方便后续直接引用别名 其他功能path常用于字符串拼接路径。 1const path = require(\"path\"); 有两个 API path.resolve() 将相对路径转换成绝对路径12const aPath = path.resolve(\"__dirname\",\"js\",\"main.js\");// aPath = 当前目录下的 js 文件夹的 main.js 文件的路径 path.join() 对路径进行拼接12const rPath = path.join(\"source\",\"js\",\"main.js\");// aPath = //source/js/main.js __dirname Node.js 中的全局变量，代表的是 项目的当前路径。常与 path 结合使用。 热更新上面我们已经提过了 webpack -w 命令，它可以实时的监控 代码的改变，从而自动进行打包，但是 有个缺点 在于它不能及时的刷新界面。 在我们 开启服务器后，是无法使用 此命令的，这个时候，如果你还想进行 自动打包，又想自动刷新界面，热更新 便是不二之选，另外 Webpack 只会热更新 发生改变的模块，不会重新加载整个页面，便可加快开发速度。 开启步骤： 修改 devServer 属性1234devServer: { hot: true,//热加载开启 inline: true,//文件改变时会自动刷新页面} 增加热更新插件12345const webpack = require(\"webpack\");//Other propertyplugins: [ new webpack.HotModuleReplacementPlugin()] 另外，只有修改 依赖的项目，才会进行实时更新。 源文件个人总结了很长时间的 Webpack 配置，希望能对你有帮助。 点击显/隐源文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197const path = require(\"path\"), webpack = require(\"webpack\"), htmlWebpackPlugin = require (\"html-webpack-plugin\"), ExtractTextPlugin = require (\"extract-text-webpack-plugin\"), marked = require(\"marked\"), renderer = new marked.Renderer(), CleanWebpackPlugin = require (\"clean-webpack-plugin\"), OpenBrowserPlugin = require (\"open-browser-webpack-plugin\"); const MyConfig = { entry: { app:\"./src/js/app.js\" }, output: { path: `${__dirname }/dist`, filename: \"js/[name].js\" // 上线时的公共路径 // publicPath: \"http://cdn.com/\", // 按需加载模块时输出的文件名称 // chunkFilename: 'js/[name].js' }, /* 生成调试用的 source-map */ devtool: \"eval-source-map\", devServer: { contentBase: \"./dist\", //本地服务器所加载 的页面所在的目录 historyApiFallback: true, //再找不到文件 的时候默认指向 index.html, inline: true,//当源文件改变时会自动刷新页面 hot: true,//热加载开启 port:8080// 设置默认监听端口 }, resolve:{ //自动扩展文件后缀名，意味着我们 require 模块可 以省略不写后缀名 extensions: [\".js\", \".html\", \".css\", \".txt\",\"less\",\"ejs\",\"json\"], //模块别名定义，直接 require('AppStore') 即可,方便后续直接引用别名 alias: { Temp: path.resolve(__dirname, \"src/templates/\") } }, module:{ rules:[ { test: /\\.(less|css)?$/ , use:ExtractTextPlugin.extract({ fallback: \"style-loader\", use:[ { loader: \"css-loader? modules\", options: { importLoaders: 1 } }, { loader:\"postcss-loa der\", options:{plugins: (loader) =&gt; [require (\"autoprefixer\")()] } }, {loader: \"less-loader\"} ] }), exclude: path.resolve (__dirname,\"./node_modules\") }, { test: /\\.js$/ , loader:\"babel-loader\", exclude: path.resolve (__dirname,\"./node_modules\"), include: path.resolve (__dirname, \"./src\"), options: {\"presets\": [\"latest\"] } }, { test:/\\.html$/ , loader:\"html-loader\", include:path.resolve(__dirname, \"./src/layer\"), exclude: path.resolve (__dirname,\"./node_modules\") }, { test:/\\.ejs$/ , loader:\"ejs-loader\", include:path.resolve(__dirname, \"./src/layer\"), exclude: path.resolve (__dirname,\"./node_modules\") }, { test: /\\.(png|jpg|jpeg|gif|svg| woff|woff2|ttf|eot|otf)$/i, loaders: [ \"file-loader\", \"url-loader?limit=8192\",{ loader: \"image-webpack-loader\", options: { gifsicle: { interlaced: false } , optipng: { optimizationLevel: 7 }, pngquant: { quality: \"65-90\", speed: 4 }, mozjpeg: { progressive: true, quality: 65 }, webp: { quality: 75 } } } ], exclude: path.resolve (__dirname,\"./node_modules\") } ] }, plugins: [ //打包前 先删除 dist 目录下的文件 new CleanWebpackPlugin( [\"dist\"], { root: __dirname,//指定插件根目录 位置 verbose: true, //开启在控制台输出 信息 dry: false //启用删除文件 } ), //生成 html new htmlWebpackPlugin({ filename: \"index.html\",//文件名 template: \"index.html\",//模板 inject: false,//js 的注入标签 //这个配置项为 true 表示自动把打包出来的文 件通过自动生成 script 标签添加到 html 中 title: \"参数 title\",//通过&lt;%= htmlWebpackPlugin.options.title %&gt; 引用 date: new Date()//通过&lt;%= htmlWebpackPlugin.options.date %&gt;引 用 //favicon: 'path/to/yourfile.ico' // excludeChunks: [''],//排除的块 // chunks: ['app','people']//选中的 块 /*minify:{ //压缩 removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true, }*/ }), //防止 CSS 文件混乱，单独生成一个 css 文件 new ExtractTextPlugin(\"./css/[name] .min.css\"), //在每个生成的 chunk 顶部添加 banner new webpack.BannerPlugin (\"Anthor:Simon\"),//添加一个显示版权声明的插 件 new webpack.optimize.UglifyJsPlugin({ compress:{//额外的压缩选项 warnings:false } // mangle: { 排除不想要压缩的对象名称 // except: ['$super', '$', 'exports', 'require', 'module', '_'] // }, }),//压缩 js //定义全局变量 new webpack.DefinePlugin({ __DEV__: JSON.stringify(JSON.parse (process.env.DEBUG || \"false\")) }), //使用 ProvidePlugin 加载的模块在使用时将不再 需要 import 和 require 进行引入 //全局自动加载模块 new webpack.ProvidePlugin({ $: \"jquery\", jQuery: \"jquery\" }), //打开服务器后 会自动打开浏览器 new OpenBrowserPlugin({url: \"http://localhost:8080\"}), //排序输出,为组件分配 ID new webpack.optimize.OccurrenceOrderPlugin (), // 启用 HMR 热加载插件 new webpack.HotModuleReplacementPlugin (), // 打印日志信息时 webpack 默认使用模块的数 字 ID 指代模块，不便于 debug， // 这个插件可以将其替换为模块的真实路径 new webpack.NamedModulesPlugin() /*提取 Chunks 中的公共内容 new webpack.optimize.CommonsChunkPlugin ({ name: [\"vendor\", \"manifest\"], // vendor libs + extracted manifest minChunks: Infinity, }),*/ /*拷贝资源插件 适用于线上场景 new CopyWebpackPlugin([{ from: __dirname + '/src/public' }]),*/ ] }; module.exports = MyConfig; 结束语转载本站文章请注明作者和出处 tomotoes.com，请勿用于任何商业用途。 .post-toc-level-4{ display:none }.post-content ol li:first-line { color: #999; font-weight: bold; }","categories":[{"name":"前端","slug":"前端","permalink":"https://tomotoes.com/blog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://tomotoes.com/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Webpack","slug":"Webpack","permalink":"https://tomotoes.com/blog/tags/Webpack/"}]},{"title":"链式向前星","date":"2017-11-22T14:24:41.000Z","path":"/chain-forward-star/","text":"这是一种神奇的数据结构。 来源听说是某个高中 Oi 菊苣发明，%%% 应用有的时候有的图可能比较稀疏而且点数较多，邻接矩阵存不下，所以就要用到邻接表。 邻接表用 vector 数组比较方便，但是 vector 比较慢。所以就有了链式向前星。 理解通过 Head 可以找到一个点的所有边,可以把 Head 理解为：链表的有实际含义的头节点 Head[N]永远保存最后一次输入的 N 点数组的下标值， Head[N]=idx; 意思是，保存 N 点的数组的下标值 而 Next 保存变化中的 Head，但不保存最后一次的 Head Edge[i].Next=Head[N]; Head[N]=idx++; 从而 Head 与 Next 数组实现链式向前星的整个过程， Head 相当于链表的有实际含义的头节点 Next 保存链表中的节点，但值得注意的是 Next 与 Head 都是通过保存下标值的方式实现的 相当于：索引式链表。 End 为终点，Value 为权值，先不提 而 Next 就相当于链表中的节点的位置，而没有头节点 Head ,是无法提取的。 保存下标值的方式很有趣，虽然开始理解起来有点怪。 int i=Head[S]; 此时 i 为最后一次保存 S 点数组的下标值，也就是最后一次输入的 S 点数据 Edge[i].End 便为最后一次输入 S 点的终点，Value 也是同理，而 S 作为出发点，不再多提 之后很关键，i=Edge[i].Next，要知道，每次的 Edge[i].Next 都是由 Head 变化而来 意思就是，i=Edge[i].Next,此后的 i 为倒数第二次输入 S 点数组的下标值！ i=Edge[Head[S]].Next;之后 i=Edge[Edge[Head[S]].Next;].Next; 从而反复循环，直到，下一条边为 0 时，便是最后一次输入的 S 点的数组的下标值 因为 最开始时，Edge[i].Next=Head[S]=0; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5;struct Node{ int End;//保存一个边的终点 int Next;//保存一个点（起点）的 除了最后一条（输入的顺序）之外的所有边的下标值 int Value;//保存一条边的权值 Node(){} Node(int a,int b,int c): End(a),Next(b),Value(c){}}Edge[maxn];bool Vis[maxn];int Head[maxn];//Head 数组 为边的索引int Idx;queue&lt;int&gt;Map;inline void AddEdge(int Start,int End,int Value){ Edge[Idx]=Node(End,Head[Start],Value); Head[Start]=Idx++;}inline void Init(){ Idx=1; memset(Edge,0,sizeof(Edge)); memset(Vis,false,sizeof(Vis)); int N,M,x,y,z; scanf(\"%d%d\",&amp;N,&amp;M); while(M--){ scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); AddEdge(x,y,z); AddEdge(y,x,z); } int Start; scanf(\"%d\",&amp;Start); Vis[Start]=true; Map.push(Start);}inline void Traverse(){ while(!Map.empty()){ int Start=Map.front(); Map.pop(); for(int i=Head[Start];i;i=Edge[i].Next){ printf(\"%d-&gt;%d=%d\\n\",Start,Edge[i].End,Edge[i].Value); if(!Vis[Edge[i].End]){ Map.push(Edge[i].End); Vis[Edge[i].End]=true; } } }}int main(){ Init(); Traverse(); return 0;}/*输入样例5 51 2 32 3 43 4 54 5 65 6 71*/ 总结 优点：不会浪费数据空间; 缺点：无法直接判断两个点是否是邻接点 链式向前星是一个很不错的数据结构，利用数组索引特性，加上其他权值，存储了整个图。","categories":[{"name":"算法","slug":"算法","permalink":"https://tomotoes.com/blog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://tomotoes.com/blog/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Vim 修炼秘籍之命令篇","date":"2017-11-22T02:20:04.000Z","path":"/order-of-vim-cultivation-cheats/","text":"总结下 Vim 常用命令以及使用技巧。 移动命令1234567891011121314151617181920212223242526272829h 左j 下 k 上 l 右space 右e 后单词尾w 后单词头b 前单词头^ 行首$ 行尾 { 上段} 下段H 屏幕上面M 屏幕中间L 屏幕下面gg 文件头G 文件尾zz 定位屏幕中间zt 定位屏幕顶部zb 定位屏幕底部mk 标记`k 转到标记 插入命令123456789101112131415a 后字符A 行尾i 前字符I 行首s 当前字符S 当前行o 下一行O 上一行cc 当前行C 后字符至行尾c+op 查找1234567891011/a 文章 n N?a 反向fa 当前行 ; ,Fa 反向ta 当前行的前一个字符 ; ,Ta 反向\\* 文章 n N\\# 反向 编辑1234567891011121314151617181920212223242526272829303132% 括号匹配&lt;&lt; 缩进u 撤回p 粘贴P 粘贴至上一行yy 复制Y 复制rt 替换R 替换模式dd 剪切D 剪切至行尾J 连接下一行x 剪切当前字符X 剪切前一个字符zc 折叠zo 打开折叠v 选中字符V 选中当前行~ 切换当前字符大小写Vu 当前行小写VU 当前行大写 寄存器123456789101112\"ayy 将当前数据复制到 a 的寄存器\"ap 将 a 的寄存器中的数据粘贴出来qa 寄存器a的开始记录op 操作~q 结束记录@a 使用寄存器\"_ 黑洞寄存器,说白了就是删除\"adiw \"aP 命令123456:w 保存文件:wq 退出编辑器，且保存文件:x 退出编辑器，且保存文件q! 放弃修改e! 放弃 修改后 载入文件 范围1234567891011121314151617介词i Inside \"x\" =&gt; \"\"a Around \"x\" =&gt; f Forward x =&gt; ...o...t To x =&gt; ...ox...名词w Words Sentencep Paragraph b ()B {}0 lineHead[]''\"\"&lt;&gt; 技巧1234567891011121314151617动词 介词 名词d/y i/a/f/t c~/b/B/w/\"/'动词 数词 名词2 d w数词 动词5 G4 jxp 交换两个字符yiw 拷贝一个单词 dk 删除当前行以及上一行dft 删除至 t 包括 t 必备1. 重复上一次修改命令","categories":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://tomotoes.com/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Vim","slug":"Vim","permalink":"https://tomotoes.com/blog/tags/Vim/"}]},{"title":"HDU1874-畅通工程续","date":"2017-11-22T01:30:59.000Z","path":"/hdu1874-problem/","text":"题目传送门 大一做的最短路模板题，很适合练手 我分别利用了 3 种数据结构+Dijkstra/Floyd 来解决，解题步骤具体如下： 邻接矩阵15ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e2+5;const int INF = 0x3f3f3f3f;int Map[maxn][maxn];bool Vis[maxn];int Dis[maxn];int N,M,S,D;inline void Init(){ memset(Map,INF,sizeof(Map)); memset(Vis,false,sizeof(Vis)); memset(Dis,0,sizeof(Dis)); int x,y,z; while(M--){ scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); Map[x][y]=Map[y][x]=min(Map[x][y],z); } scanf(\"%d%d\",&amp;S,&amp;D); for(int i=0;i&lt;N;++i){ Dis[i]=Map[S][i]; } Dis[S]=0; Vis[S]=true;}inline void Dijkstra(){ for(int l=0;l&lt;N;++l){ int Min=INF,k; for(int i=0;i&lt;N;++i){ if(!Vis[i]&amp;&amp;Dis[i]&lt;Min){ Min=Dis[i]; k=i; } } Vis[k]=true; if(Min!=INF){ for(int j=0;j&lt;N;++j){ if(!Vis[j]&amp;&amp;Dis[j]&gt;Dis[k]+Map[k][j]){ Dis[j]=Dis[k]+Map[k][j]; } } } } Dis[D]==INF?printf(\"-1n\"):printf(\"%dn\",Dis[D]);}int main(){ while(~scanf(\"%d%d\",&amp;N,&amp;M)){ Init(); Dijkstra(); } return 0;} 邻接表15ms 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5;const int INF = 0x3f3f3f3f;struct Node{ int from,to,cost; Node(int a,int b,int c):from(a),to(b),cost(c){}};vector&lt;Node&gt;Edges;vector&lt;int&gt;G[maxn];int Dis[maxn];int N,M,S,T;typedef pair&lt;int,int&gt; Pair;priority_queue&lt;Pair,vector&lt;Pair&gt;,greater&lt;Pair&gt; &gt;Q;inline void AddEdge(int x,int y,int z){ Edges.push_back(Node(x,y,z)); G[x].push_back(Edges.size()-1);}inline void Init(){ Edges.clear(); memset(Dis,INF,sizeof(Dis)); for(int i=0;i&lt;N;G[i++].clear()); int x,y,z; while(M--){ scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); AddEdge(x,y,z); AddEdge(y,x,z); } scanf(\"%d%d\",&amp;S,&amp;T); Dis[S]=0; Q.push(Pair(0,S));}inline void Dijkstra(){ int Now,Val,L; while(!Q.empty()){ Now=Q.top().second; Val=Q.top().first; Q.pop(); if(Dis[Now]&lt;Val){continue;} L=G[Now].size(); for(int i=0;i&lt;L;++i){ if(Dis[Edges[G[Now][i]].to]&gt;Dis[Now]+Edges[G[Now][i]].cost){ Dis[Edges[G[Now][i]].to]=Dis[Now]+Edges[G[Now][i]].cost; Q.push(Pair(Dis[Edges[G[Now][i]].to],Edges[G[Now][i]].to)); } } } Dis[T]==INF?printf(\"-1n\"):printf(\"%dn\",Dis[T]);}int main(){ while(~scanf(\"%d%d\",&amp;N,&amp;M)){ Init(); Dijkstra(); } return 0;} 链式向前星0ms 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2017;const int INF = 0x3f3f3f3f;struct Node{ int End; int Value; int Front; Node(){} Node(int a,int b,int c):End(a),Front(b),Value(c){}}Edge[maxn];int Head[maxn];int Dis[maxn];int N,M,S,D,Idx;typedef pair&lt;int,int&gt;Pair;priority_queue&lt;Pair,vector&lt;Pair&gt;,greater&lt;Pair&gt; &gt;Q;inline void AddEdge(int S,int D,int V){ Edge[Idx]=Node(D,Head[S],V); Head[S]=Idx++;}inline void Init(){ Idx=0; memset(Head,-1,sizeof(Head)); memset(Dis,INF,sizeof(Dis)); int x,y,z; while(M--){ scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); AddEdge(x,y,z); AddEdge(y,x,z); } scanf(\"%d%d\",&amp;S,&amp;D); Pair pNew; Dis[S]=0; pNew.first=0; pNew.second=S; Q.push(pNew);}inline void Dijkstra(){ int Now,Val; while(!Q.empty()){ Now=Q.top().second; Val=Q.top().first; Q.pop(); if(Dis[Now]&lt;Val)continue; for(int i=Head[Now];~i;i=Edge[i].Front){ if(Dis[Edge[i].End]&gt;Dis[Now]+Edge[i].Value){ Dis[Edge[i].End]=Dis[Now]+Edge[i].Value; Q.push(Pair(Dis[Edge[i].End],Edge[i].End)); } } } Dis[D]==INF?printf(\"-1n\"):printf(\"%dn\",Dis[D]);}int main(){ while(~scanf(\"%d%d\",&amp;N,&amp;M)){ Init(); Dijkstra(); } Floyd62ms 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e2+5;const int INF = 0x3f3f3f3f;int Map[maxn][maxn];int N,M,S,D;inline void Init(){ int x,y,z; memset(Map,INF,sizeof(Map)); for(int i=0;i&lt;N;++i){ Map[i][i]=0; } while(M--){ scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); Map[x][y]=Map[y][x]=min(Map[x][y],z); } scanf(\"%d%d\",&amp;S,&amp;D);}inline void Floyd(){ for(int k=0;k&lt;N;++k){ for(int i=0;i&lt;N;++i){ for(int j=0;j&lt;N;++j){ Map[i][j]=min(Map[i][j],Map[i][k]+Map[k][j]); } } } Map[S][D]==INF?printf(\"-1\\n\"):printf(\"%d\\n\",Map[S][D]);}int main(){ while(~scanf(\"%d%d\",&amp;N,&amp;M)){ Init(); Floyd(); } return 0;} 后记自从退 acm，很多东西都在遗忘…","categories":[{"name":"算法","slug":"算法","permalink":"https://tomotoes.com/blog/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://tomotoes.com/blog/tags/%E7%AE%97%E6%B3%95/"}]}]